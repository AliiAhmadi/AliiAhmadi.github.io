<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>node.example.com Is An IP Address</title><meta content="Ali Ahmadi" name=author><meta content="node.example.com is an IP address." name=description><meta content=AliAhmadi2004.ir property=og:site_name><meta content=en-us property=og:locale><meta content=https://AliAhmadi2004.ir/posts/node-example-com-is-an-ip-address/ property=og:url><meta content="node.example.com Is An IP Address" property=og:title><meta content="node.example.com is an IP address." property=og:description><meta content=article property=og:type><meta content="Ali Ahmadi" property=og:article:author><meta content=2020-12-28T06:13:05-08:00 property=og:article:published_time><meta content=Posts property=og:article:section><meta content=Python property=og:article:tag><meta content=Testing property=og:article:tag><meta content=Networking property=og:article:tag><link href=https://fonts.googleapis.com/ rel=dns-prefetch><link href=/site.css rel=stylesheet><link rel="shortcut icon" href=/favicon.svg type=image/svg+xml><link href=https://AliAhmadi2004.ir/posts/node-example-com-is-an-ip-address/ rel=canonical><body><div class=center><img alt=Me src=/self.jpg width=100></div><main><article id=content><header><h1>node.example.com Is An IP Address</h1><div class=post-meta><time datetime=2020-12-28T06:13:05-08:00>2020-12-28</time><span class=accent> ⬡ </span><a href=https://AliAhmadi2004.ir/tags/python/>#Python</a>, <a href=https://AliAhmadi2004.ir/tags/testing/>#Testing</a>, <a href=https://AliAhmadi2004.ir/tags/networking/>#Networking</a></div></header><p>Hello! Welcome to the once-yearly blog post! This year I'd like to examine the most peculiar bug I encountered at work. To set the stage, let's start with a little background.</p><span id=continue-reading></span><p>When we write <a href=https://en.wikipedia.org/wiki/URL>URLs</a> with a <a href=https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers>non-standard</a> <a href=https://en.wikipedia.org/wiki/Port_(computer_networking)>port</a> we specify the port after a <code>:</code>. With <a href=https://en.wikipedia.org/wiki/Hostname>hostnames</a> and <a href=https://en.wikipedia.org/wiki/IPv4#Addressing>IPv4</a> addresses this is straightforward. Here's some <a href=https://www.python.org/>Python</a> code to show how easy it is.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span>url </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>urllib.parse.urlparse(</span><span style=color:#b8bb26>"https://node.example.com:8000"</span><span style=color:#fdf4c1>)
</span><span style=color:#fe8019>>>> </span><span>(url.hostname, url.port)
</span><span>(</span><span style=color:#b8bb26>'node.example.com'</span><span>, </span><span style=color:#d3869b>8000</span><span>)
</span><span style=color:#fe8019>>>>
</span><span style=color:#fe8019>>>> </span><span>url </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>urllib.parse.urlparse(</span><span style=color:#b8bb26>"https://192.168.0.1:8000"</span><span style=color:#fdf4c1>)
</span><span style=color:#fe8019>>>> </span><span>(url.hostname, url.port)
</span><span>(</span><span style=color:#b8bb26>'192.168.0.1'</span><span>, </span><span style=color:#d3869b>8000</span><span>)
</span></code></pre><p>Unfortunately, when <a href=https://en.wikipedia.org/wiki/IPv6#Addressing>IPv6</a> addresses are involved some ambiguity is introduced.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span>url </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>urllib.parse.urlparse(
</span><span style=color:#d3869b>...     </span><span style=color:#b8bb26>"https://fdc8:bf8b:e62c:abcd:1111:2222:3333:4444:8000"
</span><span style=color:#d3869b>... </span><span style=color:#fdf4c1>)
</span><span style=color:#d3869b>...
</span><span style=color:#fe8019>>>> </span><span>url.hostname
</span><span style=color:#b8bb26>'fdc8'
</span><span style=color:#fe8019>>>> </span><span style=color:#fa5c4b>try</span><span>:
</span><span style=color:#d3869b>...     </span><span>url.port
</span><span style=color:#d3869b>... </span><span style=color:#fa5c4b>except </span><span style=color:#fabd2f>ValueError </span><span style=color:#fa5c4b>as </span><span>error:
</span><span style=color:#d3869b>...     </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(error)
</span><span style=color:#d3869b>...
</span><span>Port could </span><span style=color:#fe8019>not </span><span>be cast to integer value </span><span style=background:#932b1e;color:#fdf4c1>as</span><span> </span><span style=color:#b8bb26>'bf8b:e62c:abcd:1111:2222:3333:4444:8000'
</span></code></pre><p>Since IPv6 addresses use a "colon-hex" format with <a href=https://en.wikipedia.org/wiki/Hexadecimal>hexadecimal</a> fields separated by <code>:</code> we can't tell a port apart from a normal field. Notice in the example above that the hostname is truncated after the first <code>:</code>, not the one just before <code>8000</code>.<p>Fortunately, the spec for URLs recognizes this ambiguity and gives us a way to handle it. <a href=https://www.ietf.org/rfc/rfc2732.txt>RFC 2732 (<em>Format for Literal IPv6 Addresses in URL's</em>)</a> says<blockquote><p>To use a literal IPv6 address in a URL, the literal address should be enclosed in "[" and "]" characters.</blockquote><p>Update our example above to include <code>[</code> and <code>]</code> and voilà! It just works.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span>url </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>urllib.parse.urlparse(
</span><span style=color:#d3869b>...     </span><span style=color:#b8bb26>"https://[fdc8:bf8b:e62c:abcd:1111:2222:3333:4444]:8000"
</span><span style=color:#d3869b>... </span><span style=color:#fdf4c1>)
</span><span style=color:#d3869b>...
</span><span style=color:#fe8019>>>> </span><span>(url.hostname, url.port)
</span><span>(</span><span style=color:#b8bb26>'fdc8:bf8b:e62c:abcd:1111:2222:3333:4444'</span><span>, </span><span style=color:#d3869b>8000</span><span>)
</span></code></pre><p>Armed with that knowledge we can dive into the problem. 🤿<h2 id=works-on-my-machine><a aria-label="Anchor link for: works-on-my-machine" href=#works-on-my-machine></a>Works On My Machine</h2><p>A few months ago a co-worker of mine wrote a seemingly innocuous function.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>from </span><span>ipaddress </span><span style=color:#fa5c4b>import </span><span>ip_address
</span><span>
</span><span>
</span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>safe_host</span><span>(</span><span style=color:#fdf4c1>host</span><span>): 
</span><span>    </span><span style=font-style:italic;color:#928374>"""Surround `host` with brackets if it is an IPv6 address."""
</span><span>    </span><span style=color:#fa5c4b>try</span><span>:
</span><span>        </span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>ip_address(host)</span><span>.version </span><span style=color:#fe8019>== </span><span style=color:#d3869b>6</span><span>:
</span><span>            </span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"[</span><span style=color:#fdf4c1>{}</span><span style=color:#b8bb26>]"</span><span style=color:#fdf4c1>.format(host)
</span><span>    </span><span style=color:#fa5c4b>except </span><span style=color:#fabd2f>ValueError</span><span>:
</span><span>        </span><span style=color:#fa5c4b>pass
</span><span>    </span><span style=color:#fa5c4b>return </span><span>host
</span></code></pre><p>Elsewhere in the code it was invoked something like this, so that hostnames, IPv4 addresses, and IPv6 addresses could all be safely interpolated.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span>url </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>"https://</span><span style=color:#fdf4c1>{host}</span><span style=color:#b8bb26>:8000/some/path/"</span><span style=color:#fdf4c1>.format(host</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>safe_host(host))
</span></code></pre><p>Since my co-worker is awesome they wrote tests to validate their code. ✅<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>test_safe_host_with_hostname</span><span>():
</span><span>    </span><span style=font-style:italic;color:#928374>"""Hostnames should be unchanged."""
</span><span>    </span><span style=color:#fa5c4b>assert </span><span style=color:#fdf4c1>safe_host(</span><span style=color:#b8bb26>"node.example.com"</span><span style=color:#fdf4c1>) </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>"node.example.com"
</span><span>
</span><span>
</span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>test_safe_host_with_ipv4_address</span><span>():
</span><span>    </span><span style=font-style:italic;color:#928374>"""IPv4 addresses should be unchanged."""
</span><span>    </span><span style=color:#fa5c4b>assert </span><span style=color:#fdf4c1>safe_host(</span><span style=color:#b8bb26>"192.168.0.1"</span><span style=color:#fdf4c1>) </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>"192.168.0.1"
</span><span>
</span><span>
</span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>test_safe_host_with_ipv6_address</span><span>():
</span><span>    </span><span style=font-style:italic;color:#928374>"""IPv6 addresses should be surrounded by brackets."""
</span><span>    </span><span style=color:#fa5c4b>assert </span><span>(
</span><span>        </span><span style=color:#fdf4c1>safe_host(</span><span style=color:#b8bb26>"fdc8:bf8b:e62c:abcd:1111:2222:3333:4444"</span><span style=color:#fdf4c1>)
</span><span>        </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>"[fdc8:bf8b:e62c:abcd:1111:2222:3333:4444]"
</span><span>    )
</span></code></pre><p>Thank goodness they did. The Python 2 tests failed (<a href=/#drop-python2>don't look at me like that</a> 😒).<pre class=language-ini data-lang=ini style=background:#282828;color:#fdf4c1aa><code class=language-ini data-lang=ini><span>✖ </span><span style=color:#fabd2f>FAIL</span><span> py27 in </span><span style=color:#d3869b>1</span><span style=color:#fe8019>.</span><span style=color:#d3869b>83</span><span> seconds
</span><span>✔ </span><span style=color:#fabd2f>OK</span><span> py36 in </span><span style=color:#d3869b>2</span><span style=color:#fe8019>.</span><span style=color:#d3869b>82</span><span> seconds
</span><span>✔ </span><span style=color:#fabd2f>OK</span><span> py37 in </span><span style=color:#d3869b>2</span><span style=color:#fe8019>.</span><span style=color:#d3869b>621</span><span> seconds
</span><span>✔ </span><span style=color:#fabd2f>OK</span><span> py38 in </span><span style=color:#d3869b>2</span><span style=color:#fe8019>.</span><span style=color:#d3869b>524</span><span> seconds
</span><span>✔ </span><span style=color:#fabd2f>OK</span><span> py39 in </span><span style=color:#d3869b>2</span><span style=color:#fe8019>.</span><span style=color:#d3869b>461</span><span> seconds
</span></code></pre><p>Both the hostname and IPv6 address tests failed. But <em><strong>why</strong></em> did they fail? And why did the Python 3 tests pass? 🤔<p>We'll start with the hostname failure and try to isolate the bug.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span>E       </span><span style=color:#fabd2f>AssertionError</span><span>: </span><span style=color:#fa5c4b>assert </span><span style=color:#b8bb26>'[node.example.com]' </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>'node.example.com'
</span><span>E         </span><span style=color:#fe8019>- </span><span>[node.example.com]
</span><span>E         ? </span><span style=color:#fe8019>-                -
</span><span>E         </span><span style=color:#fe8019>+ </span><span>node.example.com
</span></code></pre><p>The failure says <code>node.example.com</code> was surrounded by brackets, but that's only supposed to happen for IPv6 addresses! Let's crack open a Python 2 interpreter for a quick sanity check.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fdf4c1>ipaddress.ip_address(</span><span style=color:#b8bb26>"node.example.com"</span><span style=color:#fdf4c1>)</span><span>.version
</span><span style=color:#d3869b>6
</span></code></pre><img alt="Confused Jeff Bridges" src=confused-jeff-bridges.webp style=display:block;width:100%><h2 id=what-on-htrae><a aria-label="Anchor link for: what-on-htrae" href=#what-on-htrae></a>What On Htrae?</h2><p>If, like Jeff Bridges, you were confused by that result, <em>relax</em>. We're probably not in a <a href=https://en.wikipedia.org/wiki/Bizarro_World>Bizarro World</a> where <code>node.example.com</code> is a valid IPv6 address. There must be an explanation for this behavior.<p>Things start to become a little more clear when we see the result of the <a href=https://github.com/python/cpython/blob/v3.9.0/Lib/ipaddress.py#L27-L54><code>ip_address()</code></a> function for ourselves.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fdf4c1>ipaddress.ip_address(</span><span style=color:#b8bb26>"node.example.com"</span><span style=color:#fdf4c1>)
</span><span style=color:#fdf4c1>IPv6Address(</span><span style=color:#fa5c4b>u</span><span style=color:#b8bb26>'6e6f:6465:2e65:7861:6d70:6c65:2e63:6f6d'</span><span style=color:#fdf4c1>)
</span></code></pre><p>At first glance that looks like madness. Python 3 behaves in an entirely different manner.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fa5c4b>try</span><span>:
</span><span style=color:#d3869b>...     </span><span style=color:#fdf4c1>ipaddress.ip_address(</span><span style=color:#b8bb26>"node.example.com"</span><span style=color:#fdf4c1>)
</span><span style=color:#d3869b>... </span><span style=color:#fa5c4b>except </span><span style=color:#fabd2f>ValueError </span><span style=color:#fa5c4b>as </span><span>error:
</span><span style=color:#d3869b>...     </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(error)
</span><span style=color:#d3869b>... 
</span><span style=color:#b8bb26>'node.example.com' </span><span>does </span><span style=color:#fe8019>not </span><span>appear to be an IPv4 </span><span style=color:#fe8019>or </span><span>IPv6 address
</span></code></pre><p>Python 3 knows that's not an IPv6 address, so why doesn't Python 2? The answer is in how differently the two Python versions handle text.<h2 id=text-is-hard><a aria-label="Anchor link for: text-is-hard" href=#text-is-hard></a>Text Is Hard</h2><p>Computers don't operate on text as humans think of it. They operate on numbers. That's part of why we have IP addresses to begin with. In order to represent human-readable text with computers we had to assign meaning to the numbers. Thus, <a href=https://en.wikipedia.org/wiki/ASCII>ASCII</a> was born.<p>ASCII is a <a href=https://en.wikipedia.org/wiki/Character_encoding>character encoding</a>, which means it specifies how to interpret <a href=https://en.wikipedia.org/wiki/Byte>bytes</a> as text we understand (provided you speak English). So, when your computer sees <code>01101110</code> in <a href=https://en.wikipedia.org/wiki/Binary_number>binary</a> (<code>110</code> in <a href=https://en.wikipedia.org/wiki/Decimal>decimal</a>) you see <code>n</code> because that's what ASCII says it is.<p>You can see the number to text conversion in action right in the Python interpreter.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>ord</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"n"</span><span style=color:#fdf4c1>)
</span><span style=color:#d3869b>110
</span><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>chr</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>110</span><span style=color:#fdf4c1>)
</span><span style=color:#b8bb26>'n'
</span></code></pre><p>In fact, it doesn't matter what numbering system you use. If you specify binary, <a href=https://en.wikipedia.org/wiki/Octal>octal</a>, decimal, hexadecimal, whatever... If it can be understood as the right integer it will be displayed correctly.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>chr</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>0b01101110</span><span style=color:#fdf4c1>)
</span><span style=color:#b8bb26>'n'
</span><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>chr</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>0o156</span><span style=color:#fdf4c1>)
</span><span style=color:#b8bb26>'n'
</span><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>chr</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>110</span><span style=color:#fdf4c1>)
</span><span style=color:#b8bb26>'n'
</span><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>chr</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>0x6e</span><span style=color:#fdf4c1>)
</span><span style=color:#b8bb26>'n'
</span></code></pre><p>Neat, but what does that information do for us?<h2 id=it-s-numbers-all-the-way-down><a aria-label="Anchor link for: it-s-numbers-all-the-way-down" href=#it-s-numbers-all-the-way-down></a>It's Numbers All The Way Down</h2><p>Just for giggles, humor me and let's look at the character-number translations for <code>node.example.com</code>. We'll leave out binary and octal, because they make this table uglier than it already is.<table><tbody><tr><th scope=row>Character<td>n<td>o<td>d<td>e<td>.<td>e<td>x<td>a<td>m<td>p<td>l<td>e<td>.<td>c<td>o<td>m<tr><th scope=row>Decimal<td>110<td>111<td>100<td>101<td>46<td>101<td>120<td>97<td>109<td>112<td>108<td>101<td>46<td>99<td>111<td>109<tr><th scope=row>Hexadecimal<td>6e<td>6f<td>64<td>65<td>2e<td>65<td>78<td>61<td>6d<td>70<td>6c<td>65<td>2e<td>63<td>6f<td>6d</table><p>Hey, hold on a second... If you tilt your head sideways and squint that last row looks kinda like an IPv6 address, doesn't it?<p>We should verify, just to be absolutely certain. You've still got that Python 2 interpreter open, right?<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=font-style:italic;color:#928374># Convert the characters in the hostname to hexadecimal.
</span><span style=color:#fe8019>>>> </span><span>hostname </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>"node.example.com"
</span><span style=color:#fe8019>>>> </span><span>hostname_as_hexadecimal </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>""</span><span style=color:#fdf4c1>.join(</span><span style=color:#fabd2f>hex</span><span style=color:#fdf4c1>(</span><span style=color:#fabd2f>ord</span><span style=color:#fdf4c1>(c))[</span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>:] </span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>c </span><span style=color:#fa5c4b>in </span><span style=color:#fdf4c1>hostname)
</span><span style=color:#fe8019>>>> </span><span>hostname_as_hexadecimal
</span><span style=color:#b8bb26>'6e6f64652e6578616d706c652e636f6d'
</span><span style=color:#fe8019>>>>
</span><span style=color:#fe8019>>>> </span><span style=font-style:italic;color:#928374># Convert the "IP address" to text.
</span><span style=color:#fe8019>>>> </span><span>address </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>ipaddress.ip_address(hostname)
</span><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>str</span><span style=color:#fdf4c1>(address)
</span><span style=color:#b8bb26>'6e6f:6465:2e65:7861:6d70:6c65:2e63:6f6d'
</span><span style=color:#fe8019>>>>
</span><span style=color:#fe8019>>>> </span><span style=font-style:italic;color:#928374># Remove the colons from that text.
</span><span style=color:#fe8019>>>> </span><span>address_without_colons </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>str</span><span style=color:#fdf4c1>(address).replace(</span><span style=color:#b8bb26>":"</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>""</span><span style=color:#fdf4c1>)
</span><span style=color:#fe8019>>>> </span><span>address_without_colons
</span><span style=color:#b8bb26>'6e6f64652e6578616d706c652e636f6d'
</span><span style=color:#fe8019>>>>
</span><span style=color:#fe8019>>>> </span><span style=font-style:italic;color:#928374># Compare the results and see they're equal.
</span><span style=color:#fe8019>>>> </span><span>hostname_as_hexadecimal </span><span style=color:#fe8019>== </span><span>address_without_colons
</span><span style=color:#d3869b>True
</span></code></pre><p>Sure enough, when you boil them both down to numbers they're the same mess of hexadecimal.<h2 id=the-belly-of-the-beast><a aria-label="Anchor link for: the-belly-of-the-beast" href=#the-belly-of-the-beast></a>The Belly Of The Beast</h2><p>If we dig into the source code for the Python 2 version of the <a href=https://github.com/phihag/ipaddress/blob/v1.0.23/ipaddress.py><code>ipaddress</code></a> module we ultimately come to a <a href=https://github.com/phihag/ipaddress/blob/v1.0.23/ipaddress.py#L2026-L2031>curious set of lines</a>.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=font-style:italic;color:#928374># Constructing from a packed address
</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>isinstance</span><span style=color:#fdf4c1>(address, </span><span style=color:#fabd2f>bytes</span><span style=color:#fdf4c1>)</span><span>:
</span><span>    </span><span style=color:#fdf4c1>self._check_packed_address(address, </span><span style=color:#d3869b>16</span><span style=color:#fdf4c1>)
</span><span>    bvs </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>_compat_bytes_to_byte_vals(address)
</span><span>    </span><span style=color:#fdf4c1>self</span><span>._ip </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>_compat_int_from_byte_vals(bvs, </span><span style=color:#b8bb26>'big'</span><span style=color:#fdf4c1>)
</span><span>    </span><span style=color:#fa5c4b>return
</span></code></pre><p>It turns out that, under certain conditions, the <code>ipaddress</code> module can create IPv6 addresses from raw bytes. My assumption is that it offers this behavior as a convenient way to parse IP addresses from data fresh off the <a href=https://en.wikipedia.org/wiki/Wire_data>wire</a>.<p>Does <code>node.example.com</code> meet those certain conditions? You bet it does. Because we're using Python 2 it's just <code>bytes</code> and it happens to be 16 characters long.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>isinstance</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"node.example.com"</span><span style=color:#fdf4c1>, </span><span style=color:#fabd2f>bytes</span><span style=color:#fdf4c1>)
</span><span style=color:#d3869b>True
</span><span style=color:#fe8019>>>> </span><span style=font-style:italic;color:#928374># `self._check_packed_address` basically just checks how long it is.
</span><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>len</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"node.example.com"</span><span style=color:#fdf4c1>) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>16
</span><span style=color:#d3869b>True
</span></code></pre><p>The rest of the <code>ipaddress</code> lines say to interpret the sequence of bytes as a <a href=https://en.wikipedia.org/wiki/Endianness>big-endian</a> integer. That's <a href=https://docs.python.org/3.9/library/struct.html#struct.unpack>magic</a> best left for another blog post, but the gist is that hexadecimal interpretation of <code>node.example.com</code> is condensed into a single, <strong>huge</strong> number.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>int</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"6e6f64652e6578616d706c652e636f6d"</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>16</span><span style=color:#fdf4c1>)
</span><span style=color:#d3869b>146793460745001871434687145741037825901</span><span style=color:#fa5c4b>L
</span></code></pre><p>That's an absolutely massive number, but not so massive it won't fit within the <a href=https://en.wikipedia.org/wiki/IPv6#Larger_address_space>IPv6 address space</a>.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fdf4c1>ip_address(</span><span style=color:#d3869b>146793460745001871434687145741037825901</span><span style=color:#fa5c4b>L</span><span style=color:#fdf4c1>)
</span><span style=color:#fdf4c1>IPv6Address(</span><span style=color:#fa5c4b>u</span><span style=color:#b8bb26>'6e6f:6465:2e65:7861:6d70:6c65:2e63:6f6d'</span><span style=color:#fdf4c1>)
</span></code></pre><p>As it turns out, if you're liberal in your interpretation, <code>node.example.com</code> <em>can</em> be an IPv6 address!<h2 id=you-will-be-reading-meanings><a aria-label="Anchor link for: you-will-be-reading-meanings" href=#you-will-be-reading-meanings></a>You Will Be Reading Meanings</h2><p>Obviously that's hogwash. Bizarro might be proud, but that's not what we wanted to happen.<p>There's a quote about numbers which is apocryphally attributed to <a href=https://en.wikipedia.org/wiki/W._E._B._Du_Bois>W.E.B. Du Bois</a>, but that actually comes from <a href=https://en.wikipedia.org/wiki/Harold_Geneen>Harold Geneen</a>'s book, <a href=https://en.wikiquote.org/wiki/Harold_Geneen><em>Managing</em></a>.<blockquote><p>When you have mastered the numbers, you will in fact no longer be reading numbers, any more than you read words when reading a book. You will be reading meanings.</blockquote><p>Having not read the book I'm probably taking the quote way out of context, but I think it fits our situation well.<p>As we've seen above, we can freely convert characters to numbers and back again. The root of our problem is that when we use Python 2 it considers text to be bytes. There's not a deeper, inherent meaning. Maybe the bytes are meant to be ASCII, maybe they're meant to be a long number, maybe they're meant to be an IP address. The interpretation of those bytes is up to us.<p>Python 2 doesn't differentiate between bytes and text by default. In fact, the <code>bytes</code> type is just an <a href=https://docs.python.org/3/whatsnew/2.6.html#pep-3112-byte-literals>alias</a> for <code>str</code>.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>bytes
</span><span style=color:#fe8019><</span><span style=color:#fabd2f>type </span><span style=color:#b8bb26>'str'</span><span style=color:#fe8019>>
</span><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>bytes </span><span style=color:#fe8019>is </span><span style=color:#fabd2f>str
</span><span style=color:#d3869b>True
</span></code></pre><p>To make that even more concrete, see how Python 2 considers <code>n</code> to be the same as this sequence of raw bytes.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#b8bb26>"n" </span><span style=color:#fe8019>== </span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>"\x6e"
</span><span style=color:#d3869b>True
</span></code></pre><p>Our Python 2 code doesn't work the way we want it to because raw bytes can have arbitrary meaning and we haven't told it to use our intended meaning.<p>So now we know why Python 2 interprets <code>node.example.com</code> as an IPv6 address, but why does Python 3 behave differently? More importantly, how can we reconcile the two?<h2 id=256-characters-ought-to-be-enough-for-anybody><a aria-label="Anchor link for: 256-characters-ought-to-be-enough-for-anybody" href=#256-characters-ought-to-be-enough-for-anybody></a>256 Characters Ought To Be Enough For Anybody</h2><p>ASCII looked like a good idea in the 1960's. With decades of hindsight we know the 256 characters afforded to us by <a href=https://en.wikipedia.org/wiki/ASCII#8-bit_codes>Extended ASCII</a> are insufficient to handle all of the world's writing systems. Thus, <a href=https://en.wikipedia.org/wiki/Unicode>Unicode</a> was born.<p>There are scads of blog posts, Wikipedia articles, and technical documents that will do a better job than I can of explaining Unicode in detail. You should read them if you care to, but here's my gist.<p>Unicode is a set of character encodings. <a href=https://en.wikipedia.org/wiki/UTF-8>UTF-8</a> is the dominant encoding. UTF-8 overlaps with ASCII, so ASCII characters are still just one byte. To handle the multitude of other characters, however, multiple bytes can express a single character.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#b8bb26>"n"</span><span style=color:#fdf4c1>.encode(</span><span style=color:#b8bb26>"utf-8"</span><span style=color:#fdf4c1>).hex()  </span><span style=font-style:italic;color:#928374># 1 character (U+006E), 1 byte.
</span><span style=color:#b8bb26>'6e'
</span><span style=color:#fe8019>>>> </span><span style=color:#b8bb26>"🤿"</span><span style=color:#fdf4c1>.encode(</span><span style=color:#b8bb26>"utf-8"</span><span style=color:#fdf4c1>).hex()  </span><span style=font-style:italic;color:#928374># 1 character (U+1F93F), 4 bytes.
</span><span style=color:#b8bb26>'f09fa4bf'
</span><span style=color:#fe8019>>>> </span><span style=color:#b8bb26>"悟り"</span><span style=color:#fdf4c1>.encode(</span><span style=color:#b8bb26>"utf-8"</span><span style=color:#fdf4c1>).hex()  </span><span style=font-style:italic;color:#928374># 2 characters (U+609F, U+308A), 6 bytes.
</span><span style=color:#b8bb26>'e6829fe3828a'
</span></code></pre><p>Every programming language I know of that respects the difference between raw bytes and Unicode text maintains a strict separation between the two datatypes.<p>In Python 3 this strict separation is enabled by default. Notice that it doesn't consider <code>n</code> and this sequence of raw bytes to be the same thing.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#b8bb26>"n" </span><span style=color:#fe8019>== </span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>"\x6e"
</span><span style=color:#d3869b>False
</span></code></pre><p>Even better, it doesn't consider <code>str</code> and <code>bytes</code> to be the same type.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>bytes </span><span style=color:#fe8019>is </span><span style=color:#fabd2f>str
</span><span style=color:#d3869b>False
</span><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>bytes
</span><span style=color:#fe8019><</span><span style=background:#932b1e;color:#fdf4c1>class</span><span> </span><span style=color:#b8bb26>'bytes'</span><span style=color:#fe8019>>
</span></code></pre><p>If we can get Python 2 to understand Unicode like Python 3 does, then we can probably fix our bug.<p>As an aside, if you want to learn more about how to handle Unicode in Python, check out <a href=https://nedbatchelder.com/site/aboutned.html>Ned Batchelder</a>'s talk on <a href=https://nedbatchelder.com/text/unipain.html><em>Pragmatic Unicode</em></a>.<h2 id=how-did-we-fix-it><a aria-label="Anchor link for: how-did-we-fix-it" href=#how-did-we-fix-it></a>How Did We Fix It?</h2><p>Python 2 does actually know about Unicode, but it considers Unicode text to be separate from "normal" text. At some point in Python 2 history the <a href=https://docs.python.org/2.7/library/functions.html#unicode><code>unicode</code></a> type was bolted onto the side of the language and not enabled by default. Hard to get excited about it, but it does the trick. At least they knew it's a pain to type <code>unicode()</code> all the time, so there's a handy literal syntax using a <code>u</code> prefix.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>unicode</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"node.example.com"</span><span style=color:#fdf4c1>) </span><span style=color:#fe8019>== </span><span style=color:#fa5c4b>u</span><span style=color:#b8bb26>"node.example.com"
</span><span style=color:#d3869b>True
</span></code></pre><p>This is <em>not</em> the best fix, but it did in a pinch. We added a line converting the hostname to Unicode right off the bat. We also applied the same transformation to the line with brackets. This way we always process the hostname as Unicode and we always return a Unicode value.<pre class=language-diff data-lang=diff style=background:#282828;color:#fdf4c1aa><code class=language-diff data-lang=diff><span> def safe_host(host):
</span><span>     """Surround `host` with brackets if it is an IPv6 address."""
</span><span style=color:#8ec07c>+    host = u"{}".format(host)
</span><span>     try:
</span><span>         if ip_address(host).version == 6:
</span><span style=color:#fa5c4b>-            return "[{}]".format(host)
</span><span style=color:#8ec07c>+            return u"[{}]".format(host)
</span><span>     except ValueError:
</span><span>         pass
</span></code></pre><p>Luckily for us the <code>u</code> prefix also works in Python 3 whereas <code>unicode()</code> does not (because <a href=https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str>all text is Unicode by default</a>, so the type has no business existing). In Python 3 the <code>u</code> is treated as a <a href=https://en.wikipedia.org/wiki/NOP_(code)>no-op</a>.<p>The Python 2 interpreter graciously understands the <code>unicode</code> type is not just raw <code>bytes</code>.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fabd2f>isinstance</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>u</span><span style=color:#b8bb26>"node.example.com"</span><span style=color:#fdf4c1>, </span><span style=color:#fabd2f>bytes</span><span style=color:#fdf4c1>)
</span><span style=color:#d3869b>False
</span></code></pre><p>When we use the <code>unicode</code> type the <code>ipaddress</code> module no longer tries to interpret <code>node.example.com</code> as <code>bytes</code> and convert those bytes to an IP address. We get just what we expect<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fe8019>>>> </span><span style=color:#fa5c4b>try</span><span>:
</span><span style=color:#d3869b>...     </span><span style=color:#fdf4c1>ipaddress.ip_address(</span><span style=color:#fa5c4b>u</span><span style=color:#b8bb26>"node.example.com"</span><span style=color:#fdf4c1>)
</span><span style=color:#d3869b>... </span><span style=color:#fa5c4b>except </span><span style=color:#fabd2f>ValueError </span><span style=color:#fa5c4b>as </span><span>error:
</span><span style=color:#d3869b>...     </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(error)
</span><span style=color:#d3869b>... 
</span><span style=color:#fa5c4b>u</span><span style=color:#b8bb26>'node.example.com' </span><span>does </span><span style=color:#fe8019>not </span><span>appear to be an IPv4 </span><span style=color:#fe8019>or </span><span>IPv6 address
</span></code></pre><p>and our tests pass!<pre class=language-ini data-lang=ini style=background:#282828;color:#fdf4c1aa><code class=language-ini data-lang=ini><span>✔ </span><span style=color:#fabd2f>OK</span><span> py27 in </span><span style=color:#d3869b>1</span><span style=color:#fe8019>.</span><span style=color:#d3869b>728</span><span> seconds
</span><span>✔ </span><span style=color:#fabd2f>OK</span><span> py36 in </span><span style=color:#d3869b>2</span><span style=color:#fe8019>.</span><span style=color:#d3869b>775</span><span> seconds
</span><span>✔ </span><span style=color:#fabd2f>OK</span><span> py37 in </span><span style=color:#d3869b>2</span><span style=color:#fe8019>.</span><span style=color:#d3869b>717</span><span> seconds
</span><span>✔ </span><span style=color:#fabd2f>OK</span><span> py38 in </span><span style=color:#d3869b>2</span><span style=color:#fe8019>.</span><span style=color:#d3869b>674</span><span> seconds
</span><span>✔ </span><span style=color:#fabd2f>OK</span><span> py39 in </span><span style=color:#d3869b>2</span><span style=color:#fe8019>.</span><span style=color:#d3869b>506</span><span> seconds
</span></code></pre><h2 id=reflection><a aria-label="Anchor link for: reflection" href=#reflection></a>Reflection</h2><p>I mentioned above that our fix wasn't the best. Given more time, how can we do better?<p id=drop-python2>The first (and best) solution here is to <a href=https://python3statement.org/>drop Python 2 support</a>. It's 2020 now and Python 2 is officially no longer supported. The original code worked on Python 3. The best long-term decision is to migrate the code to run on Python 3 <b>only</b> and avoid the hassle of Python 2 maintenance. Unfortunately many of the people running this code still depend on it working on Python 2, so we'll have to make that transition gracefully.<p>If a migration away from Python 2 isn't possible in the near-term, the next best thing to do is update our code so that it uses a compatibility layer like <a href=https://python-future.org/><code>future</code></a> or <a href=https://six.readthedocs.io/><code>six</code></a>. Those libraries are designed to modernize Python 2 and help smooth over issues like this one.<p>It also wouldn't hurt for us to take a page from <a href=https://lexi-lambda.github.io/about.html>Alexis King</a>'s <a href=https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/><em>Parse, don't validate</em></a> school of thought. When the hostname enters our program via user input it should <strong>immediately</strong> be converted to the <code>unicode</code> type (or maybe even an IP address type) so we don't end up solving this problem in several different places throughout the code.<p>Finally, though our program doesn't currently handle any hostnames in languages other than English, it's probably best to be thinking in Unicode anyway. Again, it's 2020 and <a href=https://en.wikipedia.org/wiki/Internationalized_domain_name>internationalized domain names</a> like <a href=https://%D0%AF%D0%BD%D0%B4%D0%B5%D0%BA%D1%81.%D1%80%D1%84>https://Яндекс.рф</a> are a thing.<p>If you made it this far, thanks for reading. It was fun to turn a brief debugging session with my co-worker into a treatise on the perils of Python 2 and the value of Unicode. See you next year! 😂</article></main><footer><nav><a href=/>Home</a> ⬡ <a href=/posts>Posts</a> ⬡ <a href=/tags>Tags</a> ⬡ <a href=/contact>Contact</a></nav><p>© 2024 Ali Ahmadi ⬡ <a href=https://github.com/AliiAhmadi>Github</a></footer>