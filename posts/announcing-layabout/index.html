<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>Announcing Layabout</title><meta content="Ali Ahmadi" name=author><meta content="Announcing Layabout, an event handler for the Slack RTM API." name=description><meta content=AliAhmadi2004.ir property=og:site_name><meta content=en-us property=og:locale><meta content=https://AliAhmadi2004.ir/posts/announcing-layabout/ property=og:url><meta content="Announcing Layabout" property=og:title><meta content="Announcing Layabout, an event handler for the Slack RTM API." property=og:description><meta content=article property=og:type><meta content="Ali Ahmadi" property=og:article:author><meta content=2018-06-30T00:16:52-07:00 property=og:article:published_time><meta content=Posts property=og:article:section><meta content=Slack property=og:article:tag><meta content=Python property=og:article:tag><meta content=Layabout property=og:article:tag><link href=https://fonts.googleapis.com/ rel=dns-prefetch><link href=/site.css rel=stylesheet><link rel="shortcut icon" href=/favicon.svg type=image/svg+xml><link href=https://AliAhmadi2004.ir/posts/announcing-layabout/ rel=canonical><body><div class=center><img alt=Me src=/self.jpg width=100></div><main><article id=content><header><h1>Announcing Layabout</h1><div class=post-meta><time datetime=2018-06-30T00:16:52-07:00>2018-06-30</time><span class=accent> ⬡ </span><a href=https://AliAhmadi2004.ir/tags/slack/>#Slack</a>, <a href=https://AliAhmadi2004.ir/tags/python/>#Python</a>, <a href=https://AliAhmadi2004.ir/tags/layabout/>#Layabout</a></div></header><p>Today I'm announcing <a href=https://layabout.readthedocs.io/en/latest/>Layabout</a>, my first official Python library. Layabout is a small event handling library on top of the <a href=https://api.slack.com/rtm>Slack Real Time Messaging (RTM) API</a>. You can get it right now on <a href=https://pypi.org/project/layabout>PyPI</a>.</p><span id=continue-reading></span><h2 id=what-s-it-good-for><a aria-label="Anchor link for: what-s-it-good-for" href=#what-s-it-good-for></a>What's It Good For?</h2><p>You can think of Layabout as a micro framework for building Slack bots. Since it wraps Slack’s RTM API it does best with tasks like interacting with users, responding to channel messages, and monitoring events. If you want more ideas on what you can do with it keep reading or check out the <a href=https://github.com/reillysiemens/layabout/tree/master/examples>examples</a>.<h2 id=why><a aria-label="Anchor link for: why" href=#why></a>Why?</h2><p>Why choose Layabout when the <a href=https://api.slack.com/events-api>Slack Events API</a> exists and there's already an officially supported <a href=https://github.com/slackapi/python-slack-events-api>events library</a>? If these points resonate with you then Layabout is for you.<ul><li>You don't want set up Flask or a similar framework.<li>You don't want to configure a reverse proxy.<li>You don't want to acquire an SSL certificate.<li>You don't want to do any of the myriad tasks associated with best practices in hosting a web app just to respond to Slack events.<li>You're satisfied with the large set of <a href=https://api.slack.com/events>events</a> supported by the <a href=https://api.slack.com/rtm>RTM API</a>.</ul><h2 id=why-not><a aria-label="Anchor link for: why-not" href=#why-not></a>Why Not?</h2><p>Layabout won't be for everone and that's OK. If these points resonate with you then you probably <em>do</em> want to use the official events library.<ul><li>You can't afford to have a persistent WebSocket connection in your application.</ul><h2 id=a-practical-example><a aria-label="Anchor link for: a-practical-example" href=#a-practical-example></a>A Practical Example</h2><p>If you want to download it and start playing with it as you read the rest of this blog post you can install it by running<pre class=language-bash data-lang=bash style=background:#282828;color:#fdf4c1aa><code class=language-bash data-lang=bash><span style=color:#fdf4c1>pip install layabout
</span></code></pre><p>Once you've got Layabout installed let's take a look at what it's capable of by borrowing the code example right from its <code>README.rst</code>.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>from </span><span>pprint </span><span style=color:#fa5c4b>import </span><span>pprint
</span><span style=color:#fa5c4b>from </span><span>layabout </span><span style=color:#fa5c4b>import </span><span>Layabout
</span><span>
</span><span>app </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>Layabout()
</span><span>
</span><span>
</span><span>@app.</span><span style=color:#fdf4c1>handle</span><span>(</span><span style=color:#b8bb26>'*'</span><span>)
</span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>debug</span><span>(</span><span style=color:#fdf4c1>slack</span><span>, </span><span style=color:#fdf4c1>event</span><span>):
</span><span>    </span><span style=font-style:italic;color:#928374>""" Pretty print every event seen by the app. """
</span><span>    </span><span style=color:#fdf4c1>pprint(event)
</span><span>
</span><span>
</span><span>@app.</span><span style=color:#fdf4c1>handle</span><span>(</span><span style=color:#b8bb26>'message'</span><span>)
</span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>echo</span><span>(</span><span style=color:#fdf4c1>slack</span><span>, </span><span style=color:#fdf4c1>event</span><span>):
</span><span>    </span><span style=font-style:italic;color:#928374>""" Echo all messages seen by the app except our own. """
</span><span>    </span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>event.get(</span><span style=color:#b8bb26>'subtype'</span><span style=color:#fdf4c1>) </span><span style=color:#fe8019>!= </span><span style=color:#b8bb26>'bot_message'</span><span>:
</span><span>        </span><span style=color:#fdf4c1>slack.rtm_send_message(event[</span><span style=color:#b8bb26>'channel'</span><span style=color:#fdf4c1>], event[</span><span style=color:#b8bb26>'text'</span><span style=color:#fdf4c1>])
</span><span>
</span><span>
</span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>someone_leaves</span><span>(</span><span style=color:#fdf4c1>events</span><span>):
</span><span>    </span><span style=font-style:italic;color:#928374>""" Return False if a member leaves, otherwise True. """
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>not </span><span style=color:#fabd2f>any</span><span style=color:#fdf4c1>(e.get(</span><span style=color:#b8bb26>'type'</span><span style=color:#fdf4c1>) </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>'member_left_channel'
</span><span style=color:#fdf4c1>                   </span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>e </span><span style=color:#fa5c4b>in </span><span style=color:#fdf4c1>events)
</span><span>
</span><span>
</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>__name__ </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>'__main__'</span><span>:
</span><span>    </span><span style=font-style:italic;color:#928374># Automatically load app token from $LAYABOUT_TOKEN and run!
</span><span>    </span><span style=color:#fdf4c1>app.run(until</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>someone_leaves)
</span><span>    </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Looks like someone left a channel!"</span><span style=color:#fdf4c1>)
</span></code></pre><p>In 28 lines of code we've used Layabout to do the following:<ul><li>Register a <code>debug</code> handler that triggers on <strong>all</strong> RTM events to pretty print them.<li>Register an <code>echo</code> handler that triggers on <code>message</code> events to echo them back into the channel they came from (unless of course we generated them).<li>Load our application token from an environment variable (<code>$LAYABOUT_TOKEN</code> by default).<li>Connect to the Slack API.<li>Continuously listen for events, calling the appropriate handlers until <code>someone_leaves</code> a channel we have access to.</ul><p>Now that we've looked at what Layabout is, why you might want to use it, and how to use it let's look a bit deeper into its design and implementation.<h2 id=design><a aria-label="Anchor link for: design" href=#design></a>Design</h2><p>If you're familiar with the superb <a href=http://flask.pocoo.org/>Flask</a> library then Layabout probably looks eerily similar to you. That's no accident and hopefully <a href=http://lucumr.pocoo.org/about/>Armin Ronacher</a> thinks imitation is the sincerest form of flattery.<p>More concretely, I think Python decorators are a powerful combination of simplicity and flexibility. They also lend themselves particularly well to event-driven workflows.<p>The heart of Layabout is its aggressively simple <a href=https://layabout.readthedocs.io/en/latest/api.html#layabout.Layabout.handle><code>Layabout.handle</code></a> method. Its normal invocation just guarantees the decorated function will accept a <code>SlackClient</code> and an event as arguments before registering it as a particular type of handler.<p>Having access to those two arguments alone opens up a wealth of possibilities. To maximize developer freedom I wanted to provide as thin a wrapper as I could on top of the already excellent <a href=https://github.com/slackapi/python-slackclient>slackclient</a> library. Giving direct access to a <code>SlackClient</code> instance meant I didn't have to write my own functions for calling out to the RTM API and I could also take advantage of its ability to call the <a href=https://api.slack.com/web>Slack Web API</a> as well.<p>I also took inspiration from <a href=https://docs.pytest.org/en/latest/>pytest</a>'s <a href=https://docs.pytest.org/en/latest/how-to/parametrize.html><code>pytest.mark.parametrize</code></a> decorator to give handlers more versatility by adding an extra <code>kwargs</code> parameter.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>from </span><span>layabout </span><span style=color:#fa5c4b>import </span><span>Layabout
</span><span>
</span><span>app </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>Layabout()
</span><span>
</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>__name__ </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>'__main__'</span><span>:
</span><span>    name </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>input</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>'What is your name? '</span><span style=color:#fdf4c1>)
</span><span>
</span><span>    @app.</span><span style=color:#fdf4c1>handle</span><span>(</span><span style=color:#b8bb26>'hello'</span><span>, </span><span style=color:#fdf4c1>kwargs</span><span style=color:#fe8019>=</span><span>{</span><span style=color:#b8bb26>'name'</span><span>: name})
</span><span>    </span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>hello</span><span>(</span><span style=color:#fdf4c1>slack</span><span>, </span><span style=color:#fdf4c1>event</span><span>, </span><span style=color:#fdf4c1>name</span><span>):
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"Hello! My name is </span><span style=color:#fdf4c1>{name}</span><span style=color:#b8bb26>."</span><span style=color:#fdf4c1>)
</span><span>
</span><span>    </span><span style=color:#fdf4c1>app.run()  </span><span style=font-style:italic;color:#928374># Run forever.
</span></code></pre><p>By adding a <code>kwargs</code> parameter we can not only use <code>Layabout.handle</code> as a decorator, but also to register functions at runtime with dynamic data. For example, this code logs events that happen, but only if they're in particular channels:<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>from </span><span>layabout </span><span style=color:#fa5c4b>import </span><span>Layabout
</span><span>
</span><span>app </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>Layabout()
</span><span>
</span><span>
</span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>log_for_channels</span><span>(</span><span style=color:#fdf4c1>slack</span><span>, </span><span style=color:#fdf4c1>event</span><span>, </span><span style=color:#fdf4c1>channels</span><span>):
</span><span>    </span><span style=font-style:italic;color:#928374>""" Log the event if it happened in a channel we care about. """
</span><span>    </span><span style=color:#fa5c4b>if </span><span>event[</span><span style=color:#b8bb26>'channel'</span><span>] </span><span style=color:#fe8019>in </span><span>channels:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>{event[</span><span style=color:#b8bb26>'type'</span><span style=color:#fdf4c1>]}</span><span style=color:#b8bb26> happened in </span><span style=color:#fdf4c1>{event[</span><span style=color:#b8bb26>'channel'</span><span style=color:#fdf4c1>]}</span><span style=color:#b8bb26>!"</span><span style=color:#fdf4c1>)
</span><span>
</span><span>
</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>__name__ </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>'__main__'</span><span>:
</span><span>    </span><span style=font-style:italic;color:#928374># A mapping of events to their respective channels.
</span><span>    event_channels </span><span style=color:#fe8019>= </span><span>(
</span><span>        (</span><span style=color:#b8bb26>'star_added'</span><span>, (</span><span style=color:#b8bb26>'G1A8FG8AE'</span><span>, </span><span style=color:#b8bb26>'C03QZSL29'</span><span>)),
</span><span>        (</span><span style=color:#b8bb26>'star_removed' </span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>'C47CSFJRK'</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>'C045BMR29'</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>'G13RTMGXY'</span><span style=color:#fdf4c1>)</span><span>),
</span><span>    )
</span><span>
</span><span>    </span><span style=font-style:italic;color:#928374># For each event register a new handler for specific channels.
</span><span>    </span><span style=color:#fa5c4b>for </span><span>event, channels </span><span style=color:#fa5c4b>in </span><span>event_channels:
</span><span>        </span><span style=color:#fdf4c1>app.handle(event, kwargs</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>{</span><span style=color:#b8bb26>'channels'</span><span style=color:#fdf4c1>: channels})(log_for_channels)
</span><span>
</span><span>    </span><span style=color:#fdf4c1>app.run()  </span><span style=font-style:italic;color:#928374># Run forever.
</span></code></pre><p>You could also use a <a href=https://en.wikipedia.org/wiki/Closure_(computer_programming)>closure</a> or default arguments on a normal function definition for this and it might look a little cleaner, but for passing runtime data to a lot of functions those can be tedious options.<p>Ultimately, I tried to write a library that I would want to use. I'm more excited now than ever to work with Slack's APIs, so in that regard I think this library is already a success.<h2 id=implementation><a aria-label="Anchor link for: implementation" href=#implementation></a>Implementation</h2><p>One of the hallmarks of this library is that it only supports Python 3.6+. I specifically chose to use only the most recent Python for three reasons:<ol><li>I wanted take advantage of all the new language features like type annotations, f-strings, better destructuring assignment, etc.<li>I didn't want to limit myself to the least common denominator by worrying about backwards compatibility.<li><a href=https://www.python.org/dev/peps/pep-0373/#update-april-2014>2020</a> is fast approaching, folks. Use Python 3 already. If you intend to keep Python as part of your stack you're rapidly running out of excuses not to modernize.</ol><p>I normally try to drink as little of the Object Oriented Kool-Aid as possible, so I tried a functional approach first, but keeping track of what was going on with connection state with a class just made sense to me. It also ended up being cleaner to keep a handler registry on an instance. Since they're self-contained you could conceivably spawn multiple instances into their own threads/processes and run them all simultaneously if you're careful with your global mutable state.<h3 id=async><a aria-label="Anchor link for: async" href=#async></a>Async</h3><p>Unfortunately I didn't see an easy way to use Python 3's <a href=https://docs.python.org/3/reference/compound_stmts.html#async-def><code>async def</code></a> because of the synchronous nature of <code>slackclient</code>'s <code>SlackClient.rtm_read</code> method. This is a Python 3 feature I'd really like to learn more about and event handling and async seem like a natural fit to me. If there's ever a reason to release a Layabout v2.0 I will probably push harder in this direction.<h3 id=type-annotations><a aria-label="Anchor link for: type-annotations" href=#type-annotations></a>Type Annotations</h3><p>From a development stance, the best part about this entire project so far has been learning how to use Python 3 <a href=https://www.python.org/dev/peps/pep-0484/>type annotations</a>. I miss them whenever I'm working with a project that doesn't have them.<p>I did have one minor annoyance while working with type annotations. Layabout keeps an internal collection of all the event handlers that have been registered to it with this signature.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=font-style:italic;color:#928374># Private type alias for the complex type of the handlers defaultdict.
</span><span>_Handlers </span><span style=color:#fe8019>= </span><span>DefaultDict[</span><span style=color:#fabd2f>str</span><span>, List[Tuple[Callable, </span><span style=color:#fabd2f>dict</span><span>]]]
</span></code></pre><p>I wanted to be even more restrictive and specify exactly what was required of the <a href=https://docs.python.org/3/library/typing.html#callable><code>Callable</code></a> by defining a <a href=https://docs.python.org/3/library/typing.html#type-aliases>type alias</a> for a <code>Handler</code>. The restrictions I sought to specify were:<ul><li>A handler must take at least two positional arguments: <ul><li>The first argument must be a <code>SlackClient</code>.<li>The second argument must be a dictionary of arbitrary types keyed by string (<code>Dict[str, Any]</code>) as that's what the Slack RTM API events are.</ul><li>If the required arguments are satisfied a handler <em>may</em> take any number of additional arguments of <code>Any</code> type.<li>A handler can return <code>Any</code> type.</ul><p>I took a stab at expressing this as<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span>Handler </span><span style=color:#fe8019>= </span><span>Callable[[SlackClient, Dict[</span><span style=color:#fabd2f>str</span><span>, Any], </span><span style=color:#d3869b>...</span><span>], Any]
</span></code></pre><p>Sadly, it would seem this doesn't work. Right now <a href=https://github.com/python/mypy>mypy</a> complains with a<pre style=background:#282828;color:#fdf4c1aa><code><span>error: Unexpected '...'
</span></code></pre><p>I've been up and down the <a href=https://github.com/python/typing>Python typing project</a>, but even after visiting <a href=https://github.com/python/typing/issues/193>issue #193</a> and <a href=https://github.com/python/typing/issues/264>issue #264</a> can't find a simple syntax for expressing a function that has a minimum arity of two with required types, but is <a href=https://en.wikipedia.org/wiki/Variadic_function>variadic</a> thereafter and <a href=https://en.wikipedia.org/wiki/Generic_programming>generic</a> in the types it accepts.<p>There may, in fact, be a way to express this type with current annotations, but I haven't figured out what it is yet. It may also be the case that the difficulty in expressing this type is an indicator that a better API exists and should be preferred. For now I've settled on just declaring that a <code>Handler</code> is a <code>Callable</code>. I've got an auxiliary function that validates handlers to let users know if they've omitted a required positional argument.<p>Despite that small inconvenience type annotations are <strong>awesome</strong>! Go use them! I now firmly believe that supplemental static analysis makes for better software, even in dynamically typed languages.<h3 id=run-method><a aria-label="Anchor link for: run-method" href=#run-method></a>Run Method</h3><p>As a final note on implementation, the <a href=https://layabout.readthedocs.io/en/latest/api.html#layabout.Layabout.run><code>Layabout.run</code></a> method only has an <code>until</code> parameter because it made it <strong>so</strong> much easier for me to unit test. If you go read the <a href=https://github.com/reillysiemens/layabout/blob/ed617cdfec4ec31b681f51697f922d4979f83cb6/tests/test_layabout.py>tests</a> you'll notice many of them get called with<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fdf4c1>layabout.run(until</span><span style=color:#fe8019>=</span><span style=color:#fa5c4b>lambda </span><span style=color:#fdf4c1>e: </span><span style=color:#d3869b>False</span><span style=color:#fdf4c1>)
</span></code></pre><p>which saves me from the headache of trying to test an otherwise infinite loop. If <code>until</code> is <code>None</code> then <code>Layabout.run</code> just uses its own private function<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>_forever</span><span>(</span><span style=color:#fdf4c1>events</span><span>: List[Dict[</span><span style=color:#fabd2f>str</span><span>, Any]]) -> </span><span style=color:#fabd2f>bool</span><span>:  </span><span style=font-style:italic;color:#928374># pragma: no cover
</span><span>    </span><span style=font-style:italic;color:#928374>""" Run Layabout in an infinite loop. """
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>True
</span></code></pre><p>Giving the looping conditional access to the events opened up enough possibilities that I decided to keep it as part of the design.<h2 id=thanks><a aria-label="Anchor link for: thanks" href=#thanks></a>Thanks</h2><p>I want to extend a special thank you to <a href=https://github.com/rawrgulmuffins>Alex LordThorsen</a>, <a href=https://github.com/RadicalZephyr>Geoff Shannon</a>, <a href=https://github.com/kyle-rader>Kyle Rader</a>, and <a href=https://mikecanoy.net>Mike Canoy</a> for their help during the initial development of this library. In particular the feedback I got on <a href=https://github.com/reillysiemens/layabout/pull/2>PR #2</a> was incredible and radically changed the library for the better.<h2 id=what-s-next><a aria-label="Anchor link for: what-s-next" href=#what-s-next></a>What's Next?</h2><p>If you're still here and Layabout sounds like fun to you then check out these links to get started.<ul><li>📜 <a href=https://layabout.readthedocs.io/en/latest/>Documentation</a><li>🐛 <a href=https://github.com/reillysiemens/layabout/issues>Bug Reports / Issues</a><li>💾 <a href=https://github.com/reillysiemens/layabout/>Source Code</a></ul><p>I <em>happily</em> entertain pull requests, so if something's not quite right feel free to jump in and submit your own fix if you're able. Happy Slacking!</article></main><footer><nav><a href=/>Home</a> ⬡ <a href=/posts>Posts</a> ⬡ <a href=/tags>Tags</a> ⬡ <a href=/contact>Contact</a></nav><p>© 2024 Ali Ahmadi ⬡ <a href=https://github.com/AliiAhmadi>Github</a></footer>