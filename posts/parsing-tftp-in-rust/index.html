<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>Parsing TFTP in Rust</title><meta content="Ali Ahmadi" name=author><meta content="Parsing TFTP in Rust" name=description><meta content=AliAhmadi2004.ir property=og:site_name><meta content=en-us property=og:locale><meta content=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/ property=og:url><meta content="Parsing TFTP in Rust" property=og:title><meta content="Parsing TFTP in Rust" property=og:description><meta content=article property=og:type><meta content="Ali Ahmadi" property=og:article:author><meta content=2022-12-31T16:45:00-08:00 property=og:article:published_time><meta content=Posts property=og:article:section><meta content=Rust property=og:article:tag><meta content=TFTP property=og:article:tag><meta content=Networking property=og:article:tag><meta content=Parsing property=og:article:tag><meta content=nom property=og:article:tag><link href=https://fonts.googleapis.com/ rel=dns-prefetch><link href=/site.css rel=stylesheet><link rel="shortcut icon" href=/favicon.svg type=image/svg+xml><link href=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/ rel=canonical><body><div class=center><img alt=Me src=/self.jpg width=100></div><main><article id=content><header><h1>Parsing TFTP in Rust</h1><div class=post-meta><time datetime=2022-12-31T16:45:00-08:00>2022-12-31</time><span class=accent> ⬡ </span><a href=https://AliAhmadi2004.ir/tags/rust/>#Rust</a>, <a href=https://AliAhmadi2004.ir/tags/tftp/>#TFTP</a>, <a href=https://AliAhmadi2004.ir/tags/networking/>#Networking</a>, <a href=https://AliAhmadi2004.ir/tags/parsing/>#Parsing</a>, <a href=https://AliAhmadi2004.ir/tags/nom/>#nom</a></div></header><p>Several years ago I did a take-home interview which asked me to write a <a href=https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol>TFTP</a> server in <a href=https://go.dev/>Go</a>. The job wasn't the right fit for me, but I enjoyed the assignment. Lately, in my spare time, I've been tinkering with a <a href=https://www.rust-lang.org/>Rust</a> implementation. Here's what I've done to parse the protocol.</p><span id=continue-reading></span><h2 id=caveat-lector><a aria-label="Anchor link for: caveat-lector" href=#caveat-lector></a>Caveat Lector</h2><p>It's natural to write a technical blog post like this in a somewhat authoritative tone. However, I am not an authority. There will be mistakes. Techniques, libraries, and even protocols change over time. Keep in mind that I am learning too and will happily accept corrections and critiques.<h2 id=why-rust><a aria-label="Anchor link for: why-rust" href=#why-rust></a>Why Rust?</h2><p>Much has been written on the merits of Rust by more qualified people. I encourage you to seek their writing and make your own decisions. For my part, I try my best to write fast, safe, and correct code. Rust lets me be more confident about my solutions without the baggage (and danger) of the last 40 years of C/C++. Recent <a href=https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html>statements</a> and <a href=https://lwn.net/Articles/910762/>events</a> would seem to agree.<p>If you know me, you might be surprised that this is my first post on Rust since I've been hyping up the language for the last 7 years. Better late than never. 😂<h2 id=what-is-tftp><a aria-label="Anchor link for: what-is-tftp" href=#what-is-tftp></a>What Is TFTP?</h2><p>If you already know the ins and outs of TFTP feel free to skip to the <a href=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/#type-design>type design</a> or <a href=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/#parsing>parsing</a> sections.<p>For those who don't know, TFTP is the <a href=https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol>Trivial File Transfer Protocol</a>, a simple means of reading and writing files over a network. Initially defined in the early 80s, the protocol was updated by <a href=https://www.rfc-editor.org/rfc/rfc1350>RFC 1350</a> in 1992. In this post I'll only cover RFC 1350. Extensions like <a href=https://www.rfc-editor.org/rfc/rfc2347>RFC 2347</a>, which adds a 6th packet type, won't be covered.<h3 id=security><a aria-label="Anchor link for: security" href=#security></a>Security</h3><p>TFTP is <em>not</em> a secure protocol. It offers no access controls, no authentication, no encryption, nothing. If you're running a TFTP server assume that any other host on the network can read the files hosted by it. You should not run a TFTP server on the open Internet.<h3 id=why-use-tftp><a aria-label="Anchor link for: why-use-tftp" href=#why-use-tftp></a>Why Use TFTP?</h3><p>If TFTP is old, insecure, and protocols like <a href=https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol>HTTP</a> & <a href=https://en.wikipedia.org/wiki/Secure_Shell>SSH</a> exist, you might wonder why you'd even bother. Fair enough. If you have other options, you probably don't need to use it.<p>That said, TFTP is still widely used, especially in server and lab environments where there are closed networks. Combined with <a href=https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol>DHCP</a> and <a href=https://en.wikipedia.org/wiki/Preboot_Execution_Environment>PXE</a> it provides an efficient means of <a href=https://en.wikipedia.org/wiki/Network_booting>network booting</a> due to its small memory footprint. This is especially important for embedded devices where memory is scarce. Additionally, if your server supports the experimental <a href=https://en.wikipedia.org/wiki/Multicast>multicast</a> option with <a href=https://www.rfc-editor.org/rfc/rfc2090>RFC 2090</a>, files can be read by multiple clients concurrently.<h2 id=protocol-overview><a aria-label="Anchor link for: protocol-overview" href=#protocol-overview></a>Protocol Overview</h2><p>TFTP is implemented atop <a href=https://en.wikipedia.org/wiki/User_Datagram_Protocol>UDP</a>, which means it can't benefit from the retransmission and reliability inherent in <a href=https://en.wikipedia.org/wiki/Transmission_Control_Protocol>TCP</a>. Clients and servers must maintain their own connections. For this reason operations are carried out in lock-step, requiring acknowledgement at each point, so that nothing is lost or misunderstood.<p>Because files might be larger than what can fit into a single packet or even in memory, TFTP operates on chunks of a file, which it calls "blocks". In RFC 1350 these blocks are always 512 bytes or less, but <a href=https://www.rfc-editor.org/rfc/rfc1783>RFC 1783</a> allows clients to negotiate different sizes which might be better on a particular network.<p>By default, initial requests are received on port <code>69</code>, the offical port assigned to TFTP by <a href=https://en.wikipedia.org/wiki/Internet_Assigned_Numbers_Authority>IANA</a>. Thereafter, the rest of a transfer is continued on a random port chosen by the server. This keeps the primary port free to receive additional requests.<h3 id=reading><a aria-label="Anchor link for: reading" href=#reading></a>Reading</h3><p>To read a file, a client sends a read request packet. If the request is valid, the server responds with the first block of data. The client sends an acknowledgement of this block and the server responds with the next block of data. The two continue this dance until there's nothing more to read.</p><img alt="A sequence diagram for a TFTP read request." src=rrq.svg><h3 id=writing><a aria-label="Anchor link for: writing" href=#writing></a>Writing</h3><p>Writing a file to a server is the inverse of reading. The client sends a write request packet and the server responds with an acknowledgement. Then the client sends the first block of data and the server responds with another acknowledgement. Rinse and repeat until the full file is transferred.</p><img alt="A sequence diagram for a TFTP write request." src=wrq.svg><h3 id=errors><a aria-label="Anchor link for: errors" href=#errors></a>Errors</h3><p>Errors are a valid response to any other packet. Most, if not all, errors are terminal. Errors are a courtesy and are neither acknowledged nor retransmitted.<h2 id=packet-types><a aria-label="Anchor link for: packet-types" href=#packet-types></a>Packet Types</h2><p>To cover the interactions above, RFC 1350 defines five packet types, each starting with a different 2 byte opcode. I'll elaborate on each of them in turn.<table><thead><tr><th>Opcode<th style=text-align:left>Operation<th>Abbreviation<tbody><tr><td>1<td style=text-align:left><a href=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/#rrq-wrq>Read Request</a><td><code>RRQ</code><tr><td>2<td style=text-align:left><a href=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/#rrq-wrq>Write Request</a><td><code>WRQ</code><tr><td>3<td style=text-align:left><a href=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/#data>Data</a><td><code>DATA</code><tr><td>4<td style=text-align:left><a href=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/#ack>Acknowledgement</a><td><code>ACK</code><tr><td>5<td style=text-align:left><a href=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/#error>Error</a><td><code>ERROR</code></table><h3 id=rrq-wrq><a aria-label="Anchor link for: rrq-wrq" href=#rrq-wrq></a><code>RRQ</code> / <code>WRQ</code></h3><p>Read and write requests share a representation, differing only by opcode. They contain a filename and a mode as <a href=https://en.wikipedia.org/wiki/Null-terminated_string>null-terminated strings</a>.<table><thead><tr><th style=text-align:left>2 bytes<th style=text-align:left>string<th style=text-align:left>1 byte<th style=text-align:left>string<th style=text-align:left>1 byte<tbody><tr><td style=text-align:left>opcode<td style=text-align:left>filename<td style=text-align:left>0<td style=text-align:left>mode<td style=text-align:left>0</table><p>Here's an example of the raw bytes in an <code>RRQ</code> for a file called <code>foobar.txt</code> in <code>octet</code> mode.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let</span><span> rrq </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>b"<span style=color:#fa5c4b>\x00\x01</span>foobar.txt<span style=color:#fa5c4b>\x00</span>octet<span style=color:#fa5c4b>\x00</span>"</span><span>;</span></code></pre><p>And here's a <code>WRQ</code> for the same file in the same mode.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let</span><span> wrq </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>b"<span style=color:#fa5c4b>\x00\x02</span>foobar.txt<span style=color:#fa5c4b>\x00</span>octet<span style=color:#fa5c4b>\x00</span>"</span><span>;</span></code></pre><h4 id=modes><a aria-label="Anchor link for: modes" href=#modes></a>Modes</h4><p>TFTP defines modes of transfer which describe how the bytes being transferred should be handled on the other end. There are three default modes.<table><thead><tr><th style=text-align:left>Mode<th style=text-align:left>Meaning<tbody><tr><td style=text-align:left>netascii<td style=text-align:left>8-bit <a href=https://en.wikipedia.org/wiki/ASCII>ASCII</a>; specifies control characters & line endings<tr><td style=text-align:left>octet<td style=text-align:left>raw 8-bit bytes; byte-for-byte identical on both ends<tr><td style=text-align:left>mail<td style=text-align:left>email the bytes to a user; obsolete even in 1992</table><p>The protocol allows for other modes to be defined by cooperating hosts, but I can't recommend that. Honestly, <code>octet</code> mode is probably sufficient for most modern needs.<h3 id=data><a aria-label="Anchor link for: data" href=#data></a><code>DATA</code></h3><p>Data packets contain the block number being sent and the corresponding data as raw bytes.<table><thead><tr><th style=text-align:left>2 bytes<th style=text-align:left>2 bytes<th style=text-align:left>n bytes<tbody><tr><td style=text-align:left>opcode<td style=text-align:left>block #<td style=text-align:left>data</table><p>Here's an example of the raw bytes in a <code>DATA</code> packet for the first block of a transfer with the contents <code>Hello, World!</code>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let</span><span> data </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>b"<span style=color:#fa5c4b>\x00\x03\x00\x01</span>Hello, World!"</span><span>;</span></code></pre><h3 id=ack><a aria-label="Anchor link for: ack" href=#ack></a><code>ACK</code></h3><p>Acknowledgements need only contain the block number they correspond to.<table><thead><tr><th style=text-align:left>2 bytes<th style=text-align:left>2 bytes<tbody><tr><td style=text-align:left>opcode<td style=text-align:left>block #</table><p>Here's an example of the raw bytes in an <code>ACK</code> packet for the first block of a transfer.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let</span><span> ack </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>b"<span style=color:#fa5c4b>\x00\x04\x00\x01</span>"</span><span>;</span></code></pre><h3 id=error><a aria-label="Anchor link for: error" href=#error></a><code>ERROR</code></h3><p>Errors contain a numeric error code and a human-readable, null-terminated string error message.<table><thead><tr><th style=text-align:left>2 bytes<th style=text-align:left>2 bytes<th style=text-align:left>string<th style=text-align:left>1 byte<tbody><tr><td style=text-align:left>opcode<td style=text-align:left>error code<td style=text-align:left>error message<td style=text-align:left>0</table><p>Here's an example of the raw bytes in an <code>ERROR</code> packet for a "File not found" error.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let</span><span> error </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>b"<span style=color:#fa5c4b>\x00\x05\x00\x01</span>File not found<span style=color:#fa5c4b>\x00</span>"</span><span>;</span></code></pre><p>By default, TFTP defines eight error codes. Since the error code is a 16-bit integer there's enough space for you and your friends to define 65,528 of your own. In practice, maybe don't.<table><thead><tr><th>Value<th style=text-align:left>Meaning<tbody><tr><td>0<td style=text-align:left>Not defined, see error message (if any).<tr><td>1<td style=text-align:left>File not found.<tr><td>2<td style=text-align:left>Access violation.<tr><td>3<td style=text-align:left>Disk full or allocation exceeded.<tr><td>4<td style=text-align:left>Illegal TFTP operation.<tr><td>5<td style=text-align:left>Unknown transfer ID.<tr><td>6<td style=text-align:left>File already exists.<tr><td>7<td style=text-align:left>No such user.<tr><td>...<td style=text-align:left>...<tr><td>65,535<td style=text-align:left>Go wild, do whatever.</table><h2 id=type-design><a aria-label="Anchor link for: type-design" href=#type-design></a>Type Design</h2><p>Now we all know entirely too much about TFTP. Let's write some code already!<p>Before I start parsing anything I find it helpful to design the resulting types. Even in application code I put on my library developer hat so I'm not annoyed by my own abstractions later.<p>Let's motivate this design by looking at some code that would use it.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let mut</span><span> buffer </span><span style=color:#fe8019>= </span><span>[</span><span style=color:#d3869b>0</span><span>; </span><span style=color:#d3869b>512</span><span>];
</span><span style=color:#fa5c4b>let</span><span> socket </span><span style=color:#fe8019>= </span><span>UdpSocket::bind(</span><span style=color:#b8bb26>"127.0.0.1:6969"</span><span>)</span><span style=color:#fe8019>?</span><span>;
</span><span style=color:#fa5c4b>let</span><span> length </span><span style=color:#fe8019>=</span><span> socket.</span><span style=color:#fabd2f>recv</span><span>(</span><span style=color:#fe8019>&</span><span style=color:#fa5c4b>mut</span><span> buffer)</span><span style=color:#fe8019>?</span><span>;
</span><span>
</span><span style=color:#fa5c4b>let</span><span> data </span><span style=color:#fe8019>= &</span><span>buffer[</span><span style=color:#fe8019>..</span><span>length];
</span><span style=color:#fabd2f>todo!</span><span>(</span><span style=color:#b8bb26>"Get our packet out of data!"</span><span>);
</span></code></pre><p>In both <a href=https://doc.rust-lang.org/std/net/struct.UdpSocket.html><code>std::net::UdpSocket</code></a> and <a href=https://docs.rs/tokio/1.23.0/tokio/net/struct.UdpSocket.html><code>tokio::net::UdpSocket</code></a> the interface that we have to work with knows nothing about packets, only raw <code>&[u8]</code> (a <a href=https://doc.rust-lang.org/std/primitive.slice.html>slice</a> of <a href=https://doc.rust-lang.org/std/primitive.u8.html>bytes</a>).<p>So, our task is to turn a <code>&[u8]</code> into something else. But what? In other implementations I've seen it's common to think of all 5 packet types as variations on a theme. We could follow suit, doing the Rusty thing and define an enum.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>enum </span><span style=color:#8ec07c>Packet </span><span>{
</span><span>    Rrq,
</span><span>    Wrq,
</span><span>    Data,
</span><span>    Ack,
</span><span>    Error,
</span><span>}
</span></code></pre><p>I might have liked my Go implemenation to look like this. If Go even had enums! 😒<p>This design choice has an unintended consequence though. As mentioned earlier, <code>RRQ</code> and <code>WRQ</code> only really matter on initial request. The remainder of the transfer isn't concerned with those variants. Even so, Rust's (appreciated) insistence on exhaustively matching patterns would make us write code like this.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>match </span><span style=color:#fabd2f>packet</span><span>(</span><span style=color:#fe8019>&</span><span>data)</span><span style=color:#fe8019>? </span><span>{
</span><span>    Packet::Data </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>handle_data</span><span>(),
</span><span>    Packet::Ack </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>handle_ack</span><span>(),
</span><span>    Packet::Error </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>handle_error</span><span>(),
</span><span>    </span><span style=color:#fe8019>_ => </span><span style=color:#fabd2f>unreachable!</span><span>(</span><span style=color:#b8bb26>"Didn't we already handle this?"</span><span>),
</span><span>}
</span></code></pre><p>Also, you might be tempted to use <a href=https://doc.rust-lang.org/std/macro.unreachable.html><code>unreachable!</code></a> for such code, but it actually <em>is</em> reachable. An ill-behaved client could send a request packet mid-connection and this design would allow it!<p>Instead, what if we were more strict with our types and split the initial <code>Request</code> from the rest of the <code>Transfer</code>?<h3 id=requests><a aria-label="Anchor link for: requests" href=#requests></a>Requests</h3><p>Before we can talk about a <code>Request</code> we should talk about its parts. When we talked about packet types we saw that <code>RRQ</code> and <code>WRQ</code> only differed by opcode and the rest of the packet was the same, a <code>filename</code> and a <code>mode</code>.<p>A <code>Mode</code> is another natural enum, but for our purposes we'll only bother with the <code>Octet</code> variant for now.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>pub enum </span><span style=color:#8ec07c>Mode </span><span>{
</span><span>    </span><span style=font-style:italic;color:#928374>// Netascii, for completeness.
</span><span>    Octet,
</span><span>    </span><span style=font-style:italic;color:#928374>// Mail, if only to gracefully send an ERROR.
</span><span>}
</span></code></pre><p>As an added convenience later on we'll add a <a href=https://doc.rust-lang.org/std/fmt/trait.Display.html><code>Display</code></a> impl for <code>Mode</code> so we can convert it to a string.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>impl </span><span>Display </span><span style=color:#fa5c4b>for </span><span style=color:#8ec07c>Mode </span><span>{
</span><span>    </span><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>fmt</span><span>(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>self</span><span>, </span><span style=color:#fdf4c1>f</span><span>: </span><span style=color:#fe8019>&</span><span style=color:#fa5c4b>mut </span><span>std::fmt::Formatter<'</span><span style=color:#fe8019>_</span><span>>) -> std::fmt::Result {
</span><span>        </span><span style=color:#fa5c4b>match </span><span style=color:#fdf4c1>self </span><span>{
</span><span>            </span><span style=color:#fa5c4b>Self</span><span>::Octet </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>write!</span><span>(f, </span><span style=color:#b8bb26>"octet"</span><span>),
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>A <code>Mode</code> combined with a <code>filename</code> make up the "inner type", which I'll call a <code>Payload</code> for lack of a better term. I've taken some liberties by declaring <code>filename</code> a <a href=https://doc.rust-lang.org/std/path/struct.PathBuf.html><code>PathBuf</code></a>, which we'll touch on <em>briefly</em> in the <a href=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/#parsing>parsing section</a>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>pub struct </span><span style=color:#8ec07c>Payload </span><span>{
</span><span>    </span><span style=color:#fa5c4b>pub </span><span style=color:#fdf4c1>filename</span><span>: PathBuf,
</span><span>    </span><span style=color:#fa5c4b>pub </span><span style=color:#fdf4c1>mode</span><span>: Mode,
</span><span>}
</span></code></pre><p>Now we can define a <code>Request</code> as an enum where each variant has a <code>Payload</code>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>pub enum </span><span style=color:#8ec07c>Request </span><span>{
</span><span>    Read(Payload),
</span><span>    Write(Payload),
</span><span>}
</span></code></pre><h3 id=transfers><a aria-label="Anchor link for: transfers" href=#transfers></a>Transfers</h3><p><code>Request</code> takes care of <code>RRQ</code> and <code>WRQ</code> packets, so a <code>Transfer</code> enum needs to take care of the remaining <code>DATA</code>, <code>ACK</code>, & <code>ERROR</code> packets. Transfers are the meat of the protocol and more complex than requests. Let's break down each variant.<h4 id=data-1><a aria-label="Anchor link for: data-1" href=#data-1></a><code>Data</code></h4><p>The <code>Data</code> variant needs to contain the <code>block</code> number, which is 2 bytes and fits neatly into a <a href=https://doc.rust-lang.org/std/primitive.u16.html><code>u16</code></a>. It also needs to contain the raw bytes of the <code>data</code>. There are many ways to represent this, including using a <a href=https://doc.rust-lang.org/std/vec/struct.Vec.html><code>Vec&LTu8></code></a> or a <a href=https://crates.io/crates/bytes><code>bytes::Bytes</code></a>. However, I think the most straightforward is as a <code>&[u8]</code> even though it introduces a <a href=https://doc.rust-lang.org/rust-by-example/scope/lifetime.html>lifetime</a>.<h4 id=ack-1><a aria-label="Anchor link for: ack-1" href=#ack-1></a><code>Ack</code></h4><p>The <code>Ack</code> packet is the simplest and only needs a <code>block</code> number. We'll use a solitary <code>u16</code> for that.<h4 id=error-1><a aria-label="Anchor link for: error-1" href=#error-1></a><code>Error</code></h4><p>The <code>Error</code> variant warrants more consideration because of the well-defined <a href=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/#error>error codes</a>. I abhor <a href=https://en.wikipedia.org/wiki/Magic_number_(programming)>magic numbers</a> in my code, so I'll prefer to define another enum called <code>ErrorCode</code> for those. For the <code>message</code> a <code>String</code> should suffice.<h5 id=errorcode><a aria-label="Anchor link for: errorcode" href=#errorcode></a><code>ErrorCode</code></h5><p>Defining an <code>ErrorCode</code> involves more boilerplate than I'd like, so I'll show three variants and leave the remainder as an exercise for the reader.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span>#[</span><span style=color:#fdf4c1>derive</span><span>(Copy, Clone)]
</span><span style=color:#fa5c4b>pub enum </span><span style=color:#8ec07c>ErrorCode </span><span>{
</span><span>    Undefined,
</span><span>    FileNotFound,
</span><span>    </span><span style=font-style:italic;color:#928374>// ...
</span><span>    Unknown(</span><span style=color:#fa5c4b>u16</span><span>),
</span><span>}
</span></code></pre><p>The <code>Undefined</code> variant is, humorously, defined, but the <code>Unknown</code> variant I've added here is not part of RFC 1350. It merely acts as a catch-all for the remaining error space. Conveniently, Rust enums allow variants to contain other data.<p>Because of this <code>Unknown</code> variant I didn't opt for a C-style enum like<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>enum </span><span style=color:#8ec07c>ErrorCode </span><span>{
</span><span>    Undefined </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>,
</span><span>    FileNotFound </span><span style=color:#fe8019>= </span><span style=color:#d3869b>1</span><span>,
</span><span>    </span><span style=font-style:italic;color:#928374>// ...
</span><span>}
</span></code></pre><p>so we can't cast an <code>ErrorCode</code> to a <code>u16</code>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=font-style:italic;color:#928374>// This explodes! 💣💥
</span><span style=color:#fa5c4b>let</span><span> code </span><span style=color:#fe8019>= </span><span>ErrorCode::Unknown(</span><span style=color:#d3869b>42</span><span>) </span><span style=color:#fe8019>as </span><span style=color:#fa5c4b>u16</span><span>;
</span></code></pre><p>However, we can add <a href=https://doc.rust-lang.org/std/convert/trait.From.html><code>From</code></a> implementations. One to convert from an <code>ErrorCode</code> to a <code>u16</code>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>impl </span><span style=color:#fabd2f>From</span><span>&LTErrorCode> </span><span style=color:#fa5c4b>for </span><span style=color:#8ec07c>u16 </span><span>{
</span><span>    </span><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>from</span><span>(</span><span style=color:#fdf4c1>error_code</span><span>: ErrorCode) -> </span><span style=color:#fa5c4b>Self </span><span>{
</span><span>        </span><span style=color:#fa5c4b>match</span><span> error_code {
</span><span>            ErrorCode::Undefined </span><span style=color:#fe8019>=> </span><span style=color:#d3869b>0</span><span>,
</span><span>            ErrorCode::FileNotFound </span><span style=color:#fe8019>=> </span><span style=color:#d3869b>1</span><span>,
</span><span>            </span><span style=font-style:italic;color:#928374>// ...
</span><span>            ErrorCode::Unknown(n) </span><span style=color:#fe8019>=></span><span> n,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>And another to convert from a <code>u16</code> to an <code>ErrorCode</code>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span>
</span><span style=color:#fa5c4b>impl </span><span style=color:#fabd2f>From</span><span><</span><span style=color:#fa5c4b>u16</span><span>> </span><span style=color:#fa5c4b>for </span><span style=color:#8ec07c>ErrorCode </span><span>{
</span><span>    </span><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>from</span><span>(</span><span style=color:#fdf4c1>code</span><span>: </span><span style=color:#fa5c4b>u16</span><span>) -> </span><span style=color:#fa5c4b>Self </span><span>{
</span><span>        </span><span style=color:#fa5c4b>match</span><span> code {
</span><span>            </span><span style=color:#d3869b>0 </span><span style=color:#fe8019>=> </span><span style=color:#fa5c4b>Self</span><span>::Undefined,
</span><span>            </span><span style=color:#d3869b>1 </span><span style=color:#fe8019>=> </span><span style=color:#fa5c4b>Self</span><span>::FileNotFound,
</span><span>            </span><span style=font-style:italic;color:#928374>// ...
</span><span>            n </span><span style=color:#fe8019>=> </span><span style=color:#fa5c4b>Self</span><span>::Unknown(n),
</span><span>        }
</span><span>    }        
</span><span>}
</span></code></pre><p>That way we still have a convenient method for conversions.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>let</span><span> code </span><span style=color:#fe8019>= </span><span style=color:#d3869b>42</span><span>;
</span><span style=color:#fa5c4b>let</span><span> error: ErrorCode </span><span style=color:#fe8019>=</span><span> code.</span><span style=color:#fabd2f>into</span><span>();
</span><span style=color:#fabd2f>assert_eq!</span><span>(error, ErrorCode::Unknown(</span><span style=color:#d3869b>42</span><span>));
</span></code></pre><h4 id=putting-it-all-together><a aria-label="Anchor link for: putting-it-all-together" href=#putting-it-all-together></a>Putting It All Together</h4><p>With each variant considered, we arrive at an <code>enum</code> that looks like this.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>pub enum </span><span style=color:#8ec07c>Transfer</span><span><'a> {
</span><span>    Data { block: </span><span style=color:#fa5c4b>u16</span><span>, data: </span><span style=color:#fe8019>&</span><span style=color:#fa5c4b>'a </span><span>[</span><span style=color:#fa5c4b>u8</span><span>] },
</span><span>    Ack { block: </span><span style=color:#fa5c4b>u16 </span><span>},
</span><span>    Error { code: ErrorCode, message: </span><span style=color:#fabd2f>String </span><span>},
</span><span>}
</span></code></pre><p>I could have defined structs to hold the inner data for each variant like I did with <code>Payload</code> earlier, but because none of the variants had the same shape I felt less inclined to do so.<h2 id=parsing><a aria-label="Anchor link for: parsing" href=#parsing></a>Parsing</h2><p>Now that we have a high-level type design to match the low-level network representation we can bridge the two by parsing. There are as many ways to shave this <a href=https://en.wikipedia.org/wiki/Yacc>Yacc</a> as there were enums in our packet types, but I settled on the <a href=https://crates.io/crates/nom><code>nom</code></a> library.<h3 id=what-is-nom><a aria-label="Anchor link for: what-is-nom" href=#what-is-nom></a>What Is nom?</h3><p>nom's own <a href=https://github.com/rust-bakery/nom/blob/6860641f1b003781f9dc1a91d0f631ff17400d1b/README.md>readme</a> does a better job of describing itself than I ever could, so I'll just let it do the talking.<blockquote><p>nom is a parser combinators library written in Rust. Its goal is to provide tools to build safe parsers without compromising the speed or memory consumption. To that end, it uses extensively Rust's strong typing and memory safety to produce fast and correct parsers, and provides functions, macros and traits to abstract most of the error prone plumbing.</blockquote><p>That sounds good and all, but what the heck is a parser combinator? Once again, nom has a great <a href=https://github.com/rust-bakery/nom/blob/6860641f1b003781f9dc1a91d0f631ff17400d1b/README.md#parser-combinators>description</a> which I encourage you to read. The gist is that, unlike other approaches, parser combinators encourage you to give your parsing a functional flair. You construct small functions to parse the simplest patterns and gradually compose them to handle more complex inputs.<p>nom has an extra advantage in that it is byte-oriented. It uses <code>&[u8]</code> as its base type, which makes it convenient for parsing network protocols. This is exactly the type we receive off the wire.<h3 id=defining-combinators><a aria-label="Anchor link for: defining-combinators" href=#defining-combinators></a>Defining Combinators</h3><p>It's finally time to define some combinators and do some parsing! Even if you're familiar with Rust, nom combinators might look more like Greek to you. I'll explain the first one in depth to show how they work and then explain only the more confusing parts as we go along. First, a small primer.<p>nom combinators return <a href=https://docs.rs/nom/7.1.1/nom/type.IResult.html><code>IResult</code></a>, a type alias for a <a href=https://doc.rust-lang.org/core/result/enum.Result.html><code>Result</code></a> that's generic over three types instead of the usual two.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>pub type </span><span style=color:#8ec07c>IResult</span><span style=color:#fe8019><</span><span>I, O, E </span><span style=color:#fe8019>= </span><span>Error&LTI></span><span style=color:#fe8019>> = </span><span style=color:#fabd2f>Result</span><span><(I, O), </span><span style=color:#fabd2f>Err</span><span>&LTE>>;
</span></code></pre><p>These types are the input type<code>I</code>, the output type <code>O</code>, and the error type <code>E</code> (usually a <a href=https://docs.rs/nom/7.1.1/nom/error/struct.Error.html>nom error</a>). I understand this type to mean that <code>I</code> will be parsed to produce <code>O</code> and any leftover <code>I</code> as long as no error <code>E</code> happens. For our purposes <code>I</code> is <code>&[u8]</code> and we'll have a couple different <code>O</code> types.<h4 id=null-strings><a aria-label="Anchor link for: null-strings" href=#null-strings></a>Null Strings</h4><p><code>null</code> references are famously a "<a href=https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/>billion dollar mistake</a>" and I can't say I like <code>null</code> any better in this protocol.<blockquote><p>Like all other strings, it is terminated with a zero byte.<br> — RFC 1350, smugly</blockquote><p>Or, you know, just tell me how long the darn string is. You're the one who put it in the packet... Yes, I know why you did it, but I don't have to like it. 🤪<p>Mercifully, the nom toolkit has everything we need to slay this beast.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>null_str</span><span>(</span><span style=color:#fdf4c1>input</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) -> IResult<</span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>], </span><span style=color:#fe8019>&</span><span style=color:#fa5c4b>str</span><span>> {
</span><span>    </span><span style=color:#fabd2f>map_res</span><span>(
</span><span>        </span><span style=color:#fabd2f>tuple</span><span>((</span><span style=color:#fabd2f>take_till</span><span>(|</span><span style=color:#fdf4c1>b</span><span>| b </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>b</span><span style=color:#b8bb26>'<span style=color:#fa5c4b>\x00</span>'</span><span>), </span><span style=color:#fabd2f>tag</span><span>(</span><span style=color:#b8bb26>b</span><span style=color:#b8bb26>"<span style=color:#fa5c4b>\x00</span>"</span><span>))),
</span><span>        |(</span><span style=color:#fdf4c1>s</span><span>, _)| std::str::from_utf8(s),
</span><span>    )(input)
</span><span>}
</span></code></pre><p>Let's work inside out to understand what <code>null_str</code> is doing.<ol><li><p><a href=https://docs.rs/nom/7.1.1/nom/bytes/complete/fn.take_till.html><code>take_till</code></a> accepts a function (here we use a closure with <code>b</code> for each byte) and collects up bytes from the <code>input</code> until one of the bytes matches the null byte, <code>b'\x00'</code>. This gets us a <code>&[u8]</code> up until, <em>but not including</em>, our zero byte.</p><li><p><a href=https://docs.rs/nom/7.1.1/nom/bytes/complete/fn.tag.html><code>tag</code></a> here just recognizes the zero byte for completeness, but we'll discard it later.</p><li><p><a href=https://docs.rs/nom/7.1.1/nom/sequence/fn.tuple.html><code>tuple</code></a> applies a tuple of parsers one by one and returns their results as a tuple.</p><li><p><a href=https://docs.rs/nom/7.1.1/nom/combinator/fn.map_res.html><code>map_res</code></a> applies a function returning a <a href=https://doc.rust-lang.org/core/result/enum.Result.html><code>Result</code></a> over the result of a parser. This gives us a nice way to call a fallible function on the results of earlier parsing, <code>take_till</code> and <code>tag</code> in this case.</p><li><p><a href=https://doc.rust-lang.org/std/str/fn.from_utf8.html><code>std::str::from_utf8</code></a>, the fallible function inside our outermost closure, converts our <code>&[u8]</code> (now sans zero byte) into a Rust <a href=https://doc.rust-lang.org/std/primitive.str.html><code>&str</code></a>, which is <strong>not</strong> terminated with a zero byte.</p><li><p><a href=https://docs.rs/nom/7.1.1/nom/type.IResult.html><code>IResult<&[u8], &str></code></a> ties it all together at the end in <code>null_str</code>'s return signature returning any unmatched <code>&[u8]</code> and a <code>&str</code> if successful.</p></ol><p>It's important to note that I'm taking another <u><b>huge</b></u> liberty here by converting these bytes to a Rust string at all. Rust strings are guaranteed to be valid <a href=https://en.wikipedia.org/wiki/UTF-8>UTF-8</a>. TFTP <a href=https://en.wikipedia.org/wiki/UTF-8#History>predates UTF-8</a>, so the protocol did not specify that these strings should be Unicode. Later, I might look into an <a href=https://doc.rust-lang.org/std/ffi/struct.OsString.html><code>OsString</code></a>, but for now non-Unicode strings will cause failures.<blockquote><p>Please, only send me UTF-8 strings.<br> — Me, wearily</blockquote><h4 id=request-combinators><a aria-label="Anchor link for: request-combinators" href=#request-combinators></a>Request Combinators</h4><p>Since <code>Request</code> only concerns itself with the first two packet types, <code>RRQ</code> and <code>WRQ</code> we can start parsing by matching only those opcodes. For convenience I used the <a href=https://crates.io/crates/num-derive><code>num-derive</code></a> crate to create a <code>RequestOpCode</code> enum so I could use <a href=https://docs.rs/num-traits/0.2.15/num_traits/cast/trait.FromPrimitive.html#method.from_u16><code>FromPrimitive::from_u16</code></a>.<p>The <code>request_opcode</code> combinator uses <a href=https://docs.rs/nom/7.1.1/nom/combinator/fn.map_opt.html><code>map_opt</code></a> and <a href=https://docs.rs/nom/7.1.1/nom/number/complete/fn.be_u16.html><code>be_u16</code></a> combinators to parse a <code>u16</code> out of the <code>input</code> and pass it to <code>from_u16</code> to construct a <code>RequestOpCode</code>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>use </span><span>num_derive::FromPrimitive;
</span><span style=color:#fa5c4b>use </span><span>num_traits::FromPrimitive;
</span><span>
</span><span>#[</span><span style=color:#fdf4c1>derive</span><span>(FromPrimitive)]
</span><span style=color:#fa5c4b>enum </span><span style=color:#8ec07c>RequestOpCode </span><span>{
</span><span>    Rrq </span><span style=color:#fe8019>= </span><span style=color:#d3869b>1</span><span>,
</span><span>    Wrq </span><span style=color:#fe8019>= </span><span style=color:#d3869b>2</span><span>,
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>request_opcode</span><span>(</span><span style=color:#fdf4c1>input</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) -> IResult<</span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>], RequestOpCode> {
</span><span>    </span><span style=color:#fabd2f>map_opt</span><span>(be_u16, RequestOpCode::from_u16)(input)
</span><span>}
</span></code></pre><p>To parse a <code>Mode</code> we <a href=https://docs.rs/nom/7.1.1/nom/combinator/fn.map.html><code>map</code></a> the result of <a href=https://docs.rs/nom/7.1.1/nom/bytes/complete/fn.tag_no_case.html><code>tag_no_case</code></a> onto our <code>Mode</code> constructor. This function would need to be <em>slightly</em> more complex if we were supporting more than <code>octet</code> mode right now, but not by much.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>mode</span><span>(</span><span style=color:#fdf4c1>input</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) -> IResult<</span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>], Mode> {
</span><span>    </span><span style=color:#fabd2f>map</span><span>(</span><span style=color:#fabd2f>tag_no_case</span><span>(</span><span style=color:#b8bb26>b</span><span style=color:#b8bb26>"octet<span style=color:#fa5c4b>\x00</span>"</span><span>), |_| Mode::Octet)(input)
</span><span>}
</span></code></pre><p>For a <code>Payload</code> we can use <a href=https://docs.rs/nom/7.1.1/nom/sequence/fn.tuple.html><code>tuple</code></a> with our <code>mode</code> combinator and <code>null_str</code> to match our filename. We then use a provided <a href=https://doc.rust-lang.org/std/convert/trait.Into.html><code>Into</code></a> impl to convert our filename <code>&str</code> to a <code>PathBuf</code>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>payload</span><span>(</span><span style=color:#fdf4c1>input</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) -> IResult<</span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>], Payload> {
</span><span>    </span><span style=color:#fa5c4b>let </span><span>(input, (filename, mode)) </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>tuple</span><span>((null_str, mode))(input)</span><span style=color:#fe8019>?</span><span>;
</span><span>    </span><span style=color:#fabd2f>Ok</span><span>((
</span><span>        input,
</span><span>        Payload {
</span><span>            filename: filename.</span><span style=color:#fabd2f>into</span><span>(),
</span><span>            mode,
</span><span>        },
</span><span>    ))
</span><span>}
</span></code></pre><p>Finally, we reach the top level of parsing and put all the rest together. The <code>request</code> function is not, itself, a combinator, which is why you see the <a href=https://docs.rs/nom/7.1.1/nom/trait.Finish.html#tymethod.finish><code>Finish::finish</code></a> calls here. We use <a href=https://docs.rs/nom/7.1.1/nom/combinator/fn.all_consuming.html><code>all_consuming</code></a> to ensure no input remains after parsing with <code>payload</code> and map the result to our respective <code>Read</code> and <code>Write</code> variants. We also hide nom errors inside a <a href=https://AliAhmadi2004.ir/posts/parsing-tftp-in-rust/#parsing-failures>custom error</a>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>request</span><span>(</span><span style=color:#fdf4c1>input</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) -> </span><span style=color:#fabd2f>Result</span><span>&LTRequest, ParsePacketError> {
</span><span>    </span><span style=color:#fa5c4b>let</span><span> iresult </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>match </span><span style=color:#fabd2f>request_opcode</span><span>(input).</span><span style=color:#fabd2f>finish</span><span>()</span><span style=color:#fe8019>? </span><span>{
</span><span>        (input, RequestOpCode::Rrq) </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>map</span><span>(</span><span style=color:#fabd2f>all_consuming</span><span>(payload), Request::Read)(input),
</span><span>        (input, RequestOpCode::Wrq) </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>map</span><span>(</span><span style=color:#fabd2f>all_consuming</span><span>(payload), Request::Write)(input),
</span><span>    };
</span><span>
</span><span>    iresult
</span><span>        .</span><span style=color:#fabd2f>finish</span><span>()
</span><span>        .</span><span style=color:#fabd2f>map</span><span>(|(_, </span><span style=color:#fdf4c1>request</span><span>)| request)
</span><span>        .</span><span style=color:#fabd2f>map_err</span><span>(ParsePacketError::from)
</span><span>}
</span></code></pre><p>With our combinators in order we can add a <code>Request::deserialize</code> method to our enum to hide the implementation details, making it much easier to switch parsing logic later if we want.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>impl </span><span style=color:#8ec07c>Request </span><span>{
</span><span>    </span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>deserialize</span><span>(</span><span style=color:#fdf4c1>bytes</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) -> </span><span style=color:#fabd2f>Result</span><span><</span><span style=color:#fa5c4b>Self</span><span>, ParsePacketError> {
</span><span>        parse::request(bytes)
</span><span>    }
</span><span>}
</span></code></pre><h4 id=parsing-failures><a aria-label="Anchor link for: parsing-failures" href=#parsing-failures></a>Parsing Failures</h4><p>You might have wondered where that <code>ParsePacketError</code> came from. It's right here. I used the <a href=https://crates.io/crates/thiserror><code>thiserror</code></a> crate because it's invaluable when crafting custom errors. Thanks, <a href=https://github.com/dtolnay><code>@dtolnay</code></a>!<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span>#[</span><span style=color:#fdf4c1>derive</span><span>(Debug, PartialEq, thiserror::Error)]
</span><span>#[</span><span style=color:#fdf4c1>error</span><span>(</span><span style=color:#b8bb26>"Error parsing packet"</span><span>)]
</span><span style=color:#fa5c4b>pub struct </span><span style=color:#8ec07c>ParsePacketError</span><span>(nom::error::Error<</span><span style=color:#fabd2f>Vec</span><span><</span><span style=color:#fa5c4b>u8</span><span>>>);
</span><span>
</span><span style=font-style:italic;color:#928374>// Custom From impl because thiserror's #[from] can't tranlate this for us.
</span><span style=color:#fa5c4b>impl </span><span style=color:#fabd2f>From</span><span>&LTnom::error::<</span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]>> </span><span style=color:#fa5c4b>for </span><span style=color:#8ec07c>ParsePacketError </span><span>{
</span><span>    </span><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>from</span><span>(</span><span style=color:#fdf4c1>err</span><span>: nom::error::Error<</span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]>) -> </span><span style=color:#fa5c4b>Self </span><span>{
</span><span>        ParsePacketError(nom::error::Error::new(err.input.</span><span style=color:#fabd2f>to_vec</span><span>(), err.code))
</span><span>    }
</span><span>}
</span></code></pre><p>You might also wonder why I converted from the original <code>nom::error::Error<&[u8]></code> to <code>nom::error::Error&LTVec&LTu8>></code>. Apparently <a href=https://doc.rust-lang.org/std/error/trait.Error.html#method.source><code>std::error::Error::source()</code></a> requires errors to be <code>dyn Error + 'static</code>, so non-<a href=https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html>static lifetimes</a> aren't allowed if you want to provide a backtrace, which I might like to do at some point. Also, it just seems reasonable for an <code>Error</code> type to own its data.<p>While we were careful to split up our <code>Request</code> and <code>Transfer</code> types I didn't see a whole lot of benefit in having separate error types, so I reused <code>ParsePacketError</code> for <code>Transfer</code> as well.<h4 id=transfer-combinators><a aria-label="Anchor link for: transfer-combinators" href=#transfer-combinators></a>Transfer Combinators</h4><p>The <code>Transfer</code> combinators are very similar to what we did for <code>Request</code>. The opcode handling is basically the same, but with different numeric values so we can't accidentally parse any other opcodes.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>use </span><span>num_derive::FromPrimitive;
</span><span style=color:#fa5c4b>use </span><span>num_traits::FromPrimitive;
</span><span>
</span><span>#[</span><span style=color:#fdf4c1>derive</span><span>(FromPrimitive)]
</span><span style=color:#fa5c4b>enum </span><span style=color:#8ec07c>TransferOpCode </span><span>{
</span><span>    Data </span><span style=color:#fe8019>= </span><span style=color:#d3869b>3</span><span>,
</span><span>    Ack </span><span style=color:#fe8019>= </span><span style=color:#d3869b>4</span><span>,
</span><span>    Error </span><span style=color:#fe8019>= </span><span style=color:#d3869b>5</span><span>,
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>transfer_opcode</span><span>(</span><span style=color:#fdf4c1>input</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) -> IResult<</span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>], TransferOpCode> {
</span><span>    </span><span style=color:#fabd2f>map_opt</span><span>(be_u16, TransferOpCode::from_u16)(input)
</span><span>}
</span></code></pre><p>For <code>Data</code> we just peel off the <code>u16</code> block number and then retain the <a href=https://docs.rs/nom/7.1.1/nom/combinator/fn.rest.html><code>rest</code></a> as the original <code>&[u8]</code>. The type alias here isn't necessary, but I like to do small things like this for organizational purposes.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>Data</span><span style=color:#fe8019><</span><span style=color:#fa5c4b>'a</span><span style=color:#fe8019>> = </span><span>(</span><span style=color:#fa5c4b>u16</span><span>, </span><span style=color:#fe8019>&</span><span style=color:#fa5c4b>'a </span><span>[</span><span style=color:#fa5c4b>u8</span><span>]);
</span><span>
</span><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>data</span><span>(</span><span style=color:#fdf4c1>input</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) -> IResult<</span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>], Data> {
</span><span>    </span><span style=color:#fabd2f>tuple</span><span>((be_u16, rest))(input)
</span><span>}
</span></code></pre><p><code>Ack</code> is, once again, the simplest. Just a named wrapper around <a href=https://docs.rs/nom/7.1.1/nom/number/complete/fn.be_u16.html><code>be_u16</code></a>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>Ack </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>u16</span><span>;
</span><span>
</span><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>ack</span><span>(</span><span style=color:#fdf4c1>input</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) -> IResult<</span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>], Ack> {
</span><span>    </span><span style=color:#fabd2f>be_u16</span><span>(input)
</span><span>}
</span></code></pre><p>The <code>Error</code> variant is nearly as simple, but we need a call to <a href=https://doc.rust-lang.org/std/result/enum.Result.html#method.map><code>Result::map</code></a> to call <a href=https://doc.rust-lang.org/std/convert/trait.Into.html><code>Into</code></a> impls and convert <code>code</code> from <code>u16</code> to <code>ErrorCode</code> and <code>message</code> from <code>&str</code> to <code>String</code>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>Error </span><span style=color:#fe8019>= </span><span>(ErrorCode, </span><span style=color:#fabd2f>String</span><span>);
</span><span>
</span><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>error</span><span>(</span><span style=color:#fdf4c1>input</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) -> IResult<</span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>], Error> {
</span><span>    </span><span style=color:#fabd2f>tuple</span><span>((be_u16, null_str))(input)
</span><span>        .</span><span style=color:#fabd2f>map</span><span>(|(</span><span style=color:#fdf4c1>input</span><span>, (</span><span style=color:#fdf4c1>code</span><span>, </span><span style=color:#fdf4c1>message</span><span>))</span><span style=color:#fe8019>| </span><span>(input, (code.</span><span style=color:#fabd2f>into</span><span>(), message.</span><span style=color:#fabd2f>into</span><span>())))
</span><span>}
</span></code></pre><p>When we put it all these combinators together in a <code>transfer</code> function it looks more complex than our earlier <code>request</code> function. That's only because there are more variants and my choice to use anonymous struct variants instead of tuple structs means there's no easy constructor, so we map over a closure. Otherwise the idea is the same as before.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>transfer</span><span>(</span><span style=color:#fdf4c1>input</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) -> </span><span style=color:#fabd2f>Result</span><span>&LTTransfer, ParsePacketError> {
</span><span>    </span><span style=color:#fa5c4b>let</span><span> iresult </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>match </span><span style=color:#fabd2f>opcode</span><span>(input).</span><span style=color:#fabd2f>finish</span><span>()</span><span style=color:#fe8019>? </span><span>{
</span><span>        (input, TransferOpCode::Data) </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>map</span><span>(</span><span style=color:#fabd2f>all_consuming</span><span>(data), |(</span><span style=color:#fdf4c1>block</span><span>, </span><span style=color:#fdf4c1>data</span><span>)| {
</span><span>            Transfer::Data { block, data }
</span><span>        })(input),
</span><span>        (input, TransferOpCode::Ack) </span><span style=color:#fe8019>=> </span><span>{
</span><span>            </span><span style=color:#fabd2f>map</span><span>(</span><span style=color:#fabd2f>all_consuming</span><span>(ack), |</span><span style=color:#fdf4c1>block</span><span>| Transfer::Ack { block })(input)
</span><span>        }
</span><span>        (input, TransferOpCode::Error) </span><span style=color:#fe8019>=> </span><span style=color:#fabd2f>map</span><span>(</span><span style=color:#fabd2f>all_consuming</span><span>(error), |(</span><span style=color:#fdf4c1>code</span><span>, </span><span style=color:#fdf4c1>message</span><span>)| {
</span><span>            Transfer::Error { code, message }
</span><span>        })(input),
</span><span>    };
</span><span>
</span><span>    iresult
</span><span>        .</span><span style=color:#fabd2f>finish</span><span>()
</span><span>        .</span><span style=color:#fabd2f>map</span><span>(|(_, </span><span style=color:#fdf4c1>transfer</span><span>)| transfer)
</span><span>        .</span><span style=color:#fabd2f>map_err</span><span>(ParsePacketError::from)
</span><span>}
</span></code></pre><p>Just like with <code>Request</code> we create a <code>Transfer::deserialize</code> method to hide these parsing details from the rest of our code.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>impl</span><span><</span><span style=color:#fa5c4b>'a</span><span>> </span><span style=color:#8ec07c>Transfer</span><span><</span><span style=color:#fa5c4b>'a</span><span>> {
</span><span>    </span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>deserialize</span><span>(</span><span style=color:#fdf4c1>bytes</span><span>: </span><span style=color:#fe8019>&</span><span style=color:#fa5c4b>'a</span><span> [</span><span style=color:#fa5c4b>u8</span><span>]) -> </span><span style=color:#fabd2f>Result</span><span><</span><span style=color:#fa5c4b>Self</span><span>, ParsePacketError> {
</span><span>        parse::transfer(bytes)
</span><span>    }
</span><span>}
</span></code></pre><h2 id=serialization><a aria-label="Anchor link for: serialization" href=#serialization></a>Serialization</h2><p>We can now read bytes into packets, which is handy, but astute readers will have noticed that you need to do the reverse if you're going to have a full TFTP conversation. Luckily, this serialization is (mostly) infallible, so there's less to explain.<p>I used <a href=https://docs.rs/bytes/1.3.0/bytes/struct.BytesMut.html><code>BytesMut</code></a> because I was already using the <a href=https://crates.io/crates/bytes><code>bytes</code></a> crate for the extension methods on the <a href=https://docs.rs/bytes/1.3.0/bytes/trait.BufMut.html><code>BufMut</code></a> trait like <a href=https://docs.rs/bytes/1.3.0/bytes/trait.BufMut.html#method.put_slice><code>put_slice</code></a>. Plus, this way I avoid an accidental panic if I pass a <code>&mut [u8]</code> and forget to size it appropriately.<h3 id=serializing-request><a aria-label="Anchor link for: serializing-request" href=#serializing-request></a>Serializing <code>Request</code></h3><p>Serializing a <code>Request</code> packet is deceptively straightfoward. We use a <code>match</code> expression to pull our <code>Payload</code> out of the request and associate with a <code>RequestOpCode</code>. Then we just serialize the opcode as a <code>u16</code> with <a href=https://docs.rs/bytes/1.3.0/bytes/trait.BufMut.html#method.put_u16><code>put_u16</code></a>. The <code>filename</code> and <code>mode</code> we serialize as null-terminated strings using a combo of <a href=https://docs.rs/bytes/1.3.0/bytes/trait.BufMut.html#method.put_slice><code>put_slice</code></a> and <a href=https://docs.rs/bytes/1.3.0/bytes/trait.BufMut.html#method.put_u8><code>put_u8</code></a>.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>impl </span><span style=color:#8ec07c>Request </span><span>{
</span><span>    </span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serialize</span><span>(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>self</span><span>, </span><span style=color:#fdf4c1>buffer</span><span>: </span><span style=color:#fe8019>&</span><span style=color:#fa5c4b>mut</span><span> BytesMut) {
</span><span>        </span><span style=color:#fa5c4b>let </span><span>(opcode, payload) </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>match </span><span style=color:#fdf4c1>self </span><span>{
</span><span>            Request::Read(payload) </span><span style=color:#fe8019>=> </span><span>(RequestOpCode::Rrq, payload),
</span><span>            Request::Write(payload) </span><span style=color:#fe8019>=> </span><span>(RequestOpCode::Wrq, payload),
</span><span>        };
</span><span>
</span><span>        buffer.</span><span style=color:#fabd2f>put_u16</span><span>(opcode </span><span style=color:#fe8019>as </span><span style=color:#fa5c4b>u16</span><span>);
</span><span>        buffer.</span><span style=color:#fabd2f>put_slice</span><span>(payload.filename.</span><span style=color:#fabd2f>to_string_lossy</span><span>().</span><span style=color:#fabd2f>as_bytes</span><span>());
</span><span>        buffer.</span><span style=color:#fabd2f>put_u8</span><span>(</span><span style=color:#d3869b>0x0</span><span>);
</span><span>        buffer.</span><span style=color:#fabd2f>put_slice</span><span>(payload.mode.</span><span style=color:#fabd2f>to_string</span><span>().</span><span style=color:#fabd2f>as_bytes</span><span>());
</span><span>        buffer.</span><span style=color:#fabd2f>put_u8</span><span>(</span><span style=color:#d3869b>0x0</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p>Converting our <code>mode</code> with <a href=https://doc.rust-lang.org/std/string/struct.String.html#method.as_bytes><code>as_bytes</code></a> through a <a href=https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string><code>to_string</code></a> is possible thanks to our earlier <a href=https://doc.rust-lang.org/std/fmt/trait.Display.html><code>Display</code></a> impl for <code>Mode</code>. The <code>filename</code> conversion to bytes through <code>PathBuf</code>'s <a href=https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.to_string_lossy><code>to_string_lossy</code></a> might reasonably raise some eyebrows. Unlike strings a Rust path is not guaranteed to be UTF-8, so any non-Unicode characters will be replaced with <a href=https://doc.rust-lang.org/std/char/constant.REPLACEMENT_CHARACTER.html>� (U+FFFD)</a>. For now, given my earlier Unicode decision I'm comfortable with this, but a more robust method is desirable.<h3 id=serializing-transfer><a aria-label="Anchor link for: serializing-transfer" href=#serializing-transfer></a>Serializing <code>Transfer</code></h3><p>Serializing a <code>Transfer</code> packet is more straightforward.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span style=color:#fa5c4b>impl </span><span style=color:#8ec07c>Transfer</span><span><'</span><span style=color:#fe8019>_</span><span>> {
</span><span>    </span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serialize</span><span>(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>self</span><span>, </span><span style=color:#fdf4c1>buffer</span><span>: </span><span style=color:#fe8019>&</span><span style=color:#fa5c4b>mut</span><span> BytesMut) {
</span><span>        </span><span style=color:#fa5c4b>match </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>self </span><span>{
</span><span>            </span><span style=color:#fa5c4b>Self</span><span>::Data { block, data } </span><span style=color:#fe8019>=> </span><span>{
</span><span>                buffer.</span><span style=color:#fabd2f>put_u16</span><span>(TransferOpCode::Data </span><span style=color:#fe8019>as </span><span style=color:#fa5c4b>u16</span><span>);
</span><span>                buffer.</span><span style=color:#fabd2f>put_u16</span><span>(block);
</span><span>                buffer.</span><span style=color:#fabd2f>put_slice</span><span>(data);
</span><span>            }
</span><span>            </span><span style=color:#fa5c4b>Self</span><span>::Ack { block } </span><span style=color:#fe8019>=> </span><span>{
</span><span>                buffer.</span><span style=color:#fabd2f>put_u16</span><span>(TransferOpCode::Ack </span><span style=color:#fe8019>as </span><span style=color:#fa5c4b>u16</span><span>);
</span><span>                buffer.</span><span style=color:#fabd2f>put_u16</span><span>(block);
</span><span>            }
</span><span>            </span><span style=color:#fa5c4b>Self</span><span>::Error { code, </span><span style=color:#fa5c4b>ref</span><span> message } </span><span style=color:#fe8019>=> </span><span>{
</span><span>                buffer.</span><span style=color:#fabd2f>put_u16</span><span>(TransferOpCode::Error </span><span style=color:#fe8019>as </span><span style=color:#fa5c4b>u16</span><span>);
</span><span>                buffer.</span><span style=color:#fabd2f>put_u16</span><span>(code.</span><span style=color:#fabd2f>into</span><span>());
</span><span>                buffer.</span><span style=color:#fabd2f>put_slice</span><span>(message.</span><span style=color:#fabd2f>as_bytes</span><span>());
</span><span>                buffer.</span><span style=color:#fabd2f>put_u8</span><span>(</span><span style=color:#d3869b>0x0</span><span>);
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>As before, with each variant we serialize a <code>u16</code> for the <code>TransferOpCode</code> and then do variant-specific serialization.<ul><li>For <code>Data</code> we serialize a <code>u16</code> for the block number and then the remainder of the data.<li>For <code>Ack</code> we also serialize a <code>u16</code> block number.<li>For <code>Error</code> we use our <a href=https://doc.rust-lang.org/std/convert/trait.From.html><code>From</code></a> impl from earlier to serialize the <code>ErrorCode</code> as a <code>u16</code> and then serialize the <code>message</code> as a null-terminated string.</ul><p>That's it! Now we can read and write structured data to and from raw bytes! 🎉<h2 id=tests><a aria-label="Anchor link for: tests" href=#tests></a>Tests</h2><p>A post on parsing wouldn't be complete without some tests showing that our code works as expected. First, we'll use the marvelous <a href=https://crates.io/crates/test-case><code>test-case</code></a> crate to bang out a few negative tests on things we expect to be errors.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span>#[</span><span style=color:#fdf4c1>test_case</span><span>(</span><span style=color:#b8bb26>b</span><span style=color:#b8bb26>"<span style=color:#fa5c4b>\x00</span>"</span><span> ; </span><span style=color:#b8bb26>"too small"</span><span>)]
</span><span>#[</span><span style=color:#fdf4c1>test_case</span><span>(</span><span style=color:#b8bb26>b</span><span style=color:#b8bb26>"<span style=color:#fa5c4b>\x00\x00</span>foobar.txt<span style=color:#fa5c4b>\x00</span>octet<span style=color:#fa5c4b>\x00</span>"</span><span> ; </span><span style=color:#b8bb26>"too low"</span><span>)]
</span><span>#[</span><span style=color:#fdf4c1>test_case</span><span>(</span><span style=color:#b8bb26>b</span><span style=color:#b8bb26>"<span style=color:#fa5c4b>\x00\x03</span>foobar.txt<span style=color:#fa5c4b>\x00</span>octet<span style=color:#fa4c4b>\x00</span>"</span><span> ; </span><span style=color:#b8bb26>"too high"</span><span>)]
</span><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>invalid_request</span><span>(</span><span style=color:#fdf4c1>input</span><span>: </span><span style=color:#fe8019>&</span><span>[</span><span style=color:#fa5c4b>u8</span><span>]) {
</span><span>    </span><span style=color:#fa5c4b>let</span><span> actual </span><span style=color:#fe8019>= </span><span>Request::deserialize(input);
</span><span>    </span><span style=font-style:italic;color:#928374>// We don't care about the nom details, so ignore them with ..
</span><span>    </span><span style=color:#fabd2f>assert!</span><span>(</span><span style=color:#fabd2f>matches!</span><span>(actual, </span><span style=color:#fabd2f>Err</span><span>(ParsePacketError(</span><span style=color:#fe8019>..</span><span>))));
</span><span>}
</span></code></pre><p>And, for good measure, we'll show that we can round-trip an <code>RRQ</code> packet from raw bytes with a stop at a proper enum in between.<pre class=language-rust data-lang=rust style=background:#282828;color:#fdf4c1aa><code class=language-rust data-lang=rust><span>#[</span><span style=color:#fdf4c1>test</span><span>]
</span><span style=color:#fa5c4b>fn </span><span style=color:#8ec07c>roundtrip_rrq</span><span>() -> </span><span style=color:#fabd2f>Result</span><span><(), ParsePacketError> {
</span><span>    </span><span style=color:#fa5c4b>let</span><span> before </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>b</span><span style=color:#b8bb26>"<span style=color:#fa5c4b>\x00\x01</span>foobar.txt<span style=color:#fa5c4b>\x00</span>octet<span style=color:#fa5c4b>\x00</span>"</span><span>;
</span><span>    </span><span style=color:#fa5c4b>let</span><span> expected </span><span style=color:#fe8019>= </span><span>Request::Read(Payload {
</span><span>        filename: </span><span style=color:#b8bb26>"foobar.txt"</span><span>.</span><span style=color:#fabd2f>into</span><span>(),
</span><span>        mode: Mode::Octet,
</span><span>    });
</span><span>    
</span><span>    </span><span style=color:#fa5c4b>let</span><span> packet </span><span style=color:#fe8019>= </span><span>Request::deserialize(before)</span><span style=color:#fe8019>?</span><span>;
</span><span>    </span><span style=font-style:italic;color:#928374>// Use an under-capacity buffer to test panics.
</span><span>    </span><span style=color:#fa5c4b>let mut</span><span> after </span><span style=color:#fe8019>= </span><span>BytesMut::with_capacity(</span><span style=color:#d3869b>4</span><span>);
</span><span>    packet.</span><span style=color:#fabd2f>serialize</span><span>(</span><span style=color:#fe8019>&</span><span style=color:#fa5c4b>mut</span><span> after);
</span><span>    
</span><span>    </span><span style=color:#fabd2f>assert_eq!</span><span>(packet, expected);
</span><span>    </span><span style=color:#fabd2f>assert_eq!</span><span>(</span><span style=color:#fe8019>&</span><span>before[</span><span style=color:#fe8019>..</span><span>], after);
</span><span>}
</span></code></pre><p>Unless you want to copy/paste all this code you'll have to trust me that the tests pass. 😉 Don't worry, I've written many more tests, but this is a blog post, not a test suite, so I'll spare you the details.<h2 id=acknowledgements><a aria-label="Anchor link for: acknowledgements" href=#acknowledgements></a><code>Ack</code>nowledgements</h2><p>Wow. You actually read all the way to the end. Congrats, and more importantly, thank you! 🙇‍♂️<p>All of the work above is part of a personal project I chip away at in my spare time, but I don't do it alone. I owe a huge debt of gratitude to my friend & Rust mentor, <a href=https://zefira.dev/>Zefira</a>, who has spent countless hours letting me pick her brain on every minute detail of this TFTP code. I could not have written this blog post without her!<p>I also need to thank Yiannis M (<a href=https://github.com/oblique><code>@oblique</code></a>) for their work on the <a href=https://crates.io/crates/async-tftp><code>async-tftp-rs</code></a> crate, from which I have borrowed liberally and learned a great deal. You may recognize some combinators if you dive into that code.<p>Finally, I can't thank my wife enough helping me edit this. There are many fewer mistakes as a result.<p>The source code for the rest of the project is not currently public, but when I'm more confident in it I'll definitely share more details. Meanwhile, I welcome any and all suggestions on how to make what I've written here more efficient and safe.</article></main><footer><nav><a href=/>Home</a> ⬡ <a href=/posts>Posts</a> ⬡ <a href=/tags>Tags</a> ⬡ <a href=/contact>Contact</a></nav><p>© 2024 Ali Ahmadi ⬡ <a href=https://github.com/AliiAhmadi>Github</a></footer>